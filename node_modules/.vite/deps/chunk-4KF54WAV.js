import {
  addPositionPropertiesToSections,
  applyDefaultDate,
  areDatesEqual,
  createDateStrForInputFromSections,
  getDefaultReferenceDate,
  getTodayDate,
  replaceInvalidDateByNull,
  splitFieldInternalAndForwardedProps,
  useDefaultDates,
  useField,
  useUtils,
  validateDate
} from "./chunk-35TE5P2F.js";
import {
  _objectWithoutPropertiesLoose,
  init_objectWithoutPropertiesLoose
} from "./chunk-OQHL3TZH.js";
import {
  _extends,
  init_extends
} from "./chunk-ZW3DX352.js";

// node_modules/@mui/x-date-pickers-pro/SingleInputDateRangeField/useSingleInputDateRangeField.js
init_extends();

// node_modules/@mui/x-date-pickers-pro/internals/utils/valueManagers.js
init_extends();
init_objectWithoutPropertiesLoose();

// node_modules/@mui/x-date-pickers-pro/internals/utils/date-fields-utils.js
init_extends();
var splitDateRangeSections = (sections) => {
  const startDateSections = [];
  const endDateSections = [];
  sections.forEach((section) => {
    if (section.dateName === "start") {
      startDateSections.push(section);
    } else {
      endDateSections.push(section);
    }
  });
  return {
    startDate: startDateSections,
    endDate: endDateSections
  };
};
var removeLastSeparator = (dateSections) => dateSections.map((section, sectionIndex) => {
  if (sectionIndex === dateSections.length - 1) {
    return _extends({}, section, {
      separator: null
    });
  }
  return section;
});

// node_modules/@mui/x-date-pickers-pro/internals/utils/valueManagers.js
var _excluded = ["value", "referenceDate"];
var rangeValueManager = {
  emptyValue: [null, null],
  getTodayValue: (utils, timezone, valueType) => [getTodayDate(utils, timezone, valueType), getTodayDate(utils, timezone, valueType)],
  getInitialReferenceValue: (_ref) => {
    let {
      value,
      referenceDate: referenceDateProp
    } = _ref, params = _objectWithoutPropertiesLoose(_ref, _excluded);
    const shouldKeepStartDate = value[0] != null && params.utils.isValid(value[0]);
    const shouldKeepEndDate = value[1] != null && params.utils.isValid(value[1]);
    if (shouldKeepStartDate && shouldKeepEndDate) {
      return value;
    }
    const referenceDate = referenceDateProp != null ? referenceDateProp : getDefaultReferenceDate(params);
    return [shouldKeepStartDate ? value[0] : referenceDate, shouldKeepEndDate ? value[1] : referenceDate];
  },
  cleanValue: (utils, value) => value.map((date) => replaceInvalidDateByNull(utils, date)),
  areValuesEqual: (utils, a, b) => areDatesEqual(utils, a[0], b[0]) && areDatesEqual(utils, a[1], b[1]),
  isSameError: (a, b) => b !== null && a[1] === b[1] && a[0] === b[0],
  hasError: (error) => error[0] != null || error[1] != null,
  defaultErrorState: [null, null],
  getTimezone: (utils, value) => {
    const timezoneStart = value[0] == null || !utils.isValid(value[0]) ? null : utils.getTimezone(value[0]);
    const timezoneEnd = value[1] == null || !utils.isValid(value[1]) ? null : utils.getTimezone(value[1]);
    if (timezoneStart != null && timezoneEnd != null && timezoneStart !== timezoneEnd) {
      throw new Error("MUI: The timezone of the start and the end date should be the same");
    }
    return timezoneStart != null ? timezoneStart : timezoneEnd;
  },
  setTimezone: (utils, timezone, value) => [value[0] == null ? null : utils.setTimezone(value[0], timezone), value[1] == null ? null : utils.setTimezone(value[1], timezone)]
};
var rangeFieldValueManager = {
  updateReferenceValue: (utils, value, prevReferenceValue) => {
    const shouldKeepStartDate = value[0] != null && utils.isValid(value[0]);
    const shouldKeepEndDate = value[1] != null && utils.isValid(value[1]);
    if (!shouldKeepStartDate && !shouldKeepEndDate) {
      return prevReferenceValue;
    }
    if (shouldKeepStartDate && shouldKeepEndDate) {
      return value;
    }
    if (shouldKeepStartDate) {
      return [value[0], prevReferenceValue[0]];
    }
    return [prevReferenceValue[1], value[1]];
  },
  getSectionsFromValue: (utils, [start, end], fallbackSections, isRTL, getSectionsFromDate) => {
    const separatedFallbackSections = fallbackSections == null ? {
      startDate: null,
      endDate: null
    } : splitDateRangeSections(fallbackSections);
    const getSections = (newDate, fallbackDateSections, position) => {
      const shouldReUsePrevDateSections = !utils.isValid(newDate) && !!fallbackDateSections;
      if (shouldReUsePrevDateSections) {
        return fallbackDateSections;
      }
      const sections = getSectionsFromDate(newDate);
      return sections.map((section, sectionIndex) => {
        if (sectionIndex === sections.length - 1 && position === "start") {
          return _extends({}, section, {
            dateName: position,
            endSeparator: `${section.endSeparator}${isRTL ? "⁩ – ⁦" : " – "}`
          });
        }
        return _extends({}, section, {
          dateName: position
        });
      });
    };
    return addPositionPropertiesToSections([...getSections(start, separatedFallbackSections.startDate, "start"), ...getSections(end, separatedFallbackSections.endDate, "end")], isRTL);
  },
  getValueStrFromSections: (sections, isRTL) => {
    const dateRangeSections = splitDateRangeSections(sections);
    return createDateStrForInputFromSections([...dateRangeSections.startDate, ...dateRangeSections.endDate], isRTL);
  },
  parseValueStr: (valueStr, referenceValue, parseDate) => {
    const [startStr, endStr] = valueStr.split("–");
    return [startStr, endStr].map((dateStr, index) => {
      if (dateStr == null) {
        return null;
      }
      return parseDate(dateStr.trim(), referenceValue[index]);
    });
  },
  getActiveDateManager: (utils, state, activeSection) => {
    const index = activeSection.dateName === "start" ? 0 : 1;
    const updateDateInRange = (newDate, prevDateRange) => index === 0 ? [newDate, prevDateRange[1]] : [prevDateRange[0], newDate];
    return {
      date: state.value[index],
      referenceDate: state.referenceValue[index],
      getSections: (sections) => {
        const dateRangeSections = splitDateRangeSections(sections);
        if (index === 0) {
          return removeLastSeparator(dateRangeSections.startDate);
        }
        return dateRangeSections.endDate;
      },
      getNewValuesFromNewActiveDate: (newActiveDate) => ({
        value: updateDateInRange(newActiveDate, state.value),
        referenceValue: newActiveDate == null || !utils.isValid(newActiveDate) ? state.referenceValue : updateDateInRange(newActiveDate, state.referenceValue)
      })
    };
  }
};

// node_modules/@mui/x-date-pickers-pro/internals/utils/validation/validateDateRange.js
init_extends();
init_objectWithoutPropertiesLoose();

// node_modules/@mui/x-date-pickers-pro/internals/utils/date-utils.js
var isRangeValid = (utils, range) => {
  return Boolean(range && range[0] && range[1] && !utils.isBefore(range[1], range[0]));
};
var isWithinRange = (utils, day, range) => {
  return isRangeValid(utils, range) && utils.isWithinRange(day, range);
};
var isStartOfRange = (utils, day, range) => {
  return isRangeValid(utils, range) && utils.isSameDay(day, range[0]);
};
var isEndOfRange = (utils, day, range) => {
  return isRangeValid(utils, range) && utils.isSameDay(day, range[1]);
};

// node_modules/@mui/x-date-pickers-pro/internals/utils/validation/validateDateRange.js
var _excluded2 = ["shouldDisableDate"];
var validateDateRange = ({
  props,
  value,
  adapter
}) => {
  const [start, end] = value;
  const {
    shouldDisableDate
  } = props, otherProps = _objectWithoutPropertiesLoose(props, _excluded2);
  const dateValidations = [validateDate({
    adapter,
    value: start,
    props: _extends({}, otherProps, {
      shouldDisableDate: (day) => !!(shouldDisableDate != null && shouldDisableDate(day, "start"))
    })
  }), validateDate({
    adapter,
    value: end,
    props: _extends({}, otherProps, {
      shouldDisableDate: (day) => !!(shouldDisableDate != null && shouldDisableDate(day, "end"))
    })
  })];
  if (dateValidations[0] || dateValidations[1]) {
    return dateValidations;
  }
  if (start === null || end === null) {
    return [null, null];
  }
  if (!isRangeValid(adapter.utils, value)) {
    return ["invalidRange", "invalidRange"];
  }
  return [null, null];
};

// node_modules/@mui/x-date-pickers-pro/SingleInputDateRangeField/useSingleInputDateRangeField.js
var useDefaultizedDateRangeFieldProps = (props) => {
  var _props$disablePast, _props$disableFuture, _props$format;
  const utils = useUtils();
  const defaultDates = useDefaultDates();
  return _extends({}, props, {
    disablePast: (_props$disablePast = props.disablePast) != null ? _props$disablePast : false,
    disableFuture: (_props$disableFuture = props.disableFuture) != null ? _props$disableFuture : false,
    format: (_props$format = props.format) != null ? _props$format : utils.formats.keyboardDate,
    minDate: applyDefaultDate(utils, props.minDate, defaultDates.minDate),
    maxDate: applyDefaultDate(utils, props.maxDate, defaultDates.maxDate)
  });
};
var useSingleInputDateRangeField = ({
  props: inProps,
  inputRef
}) => {
  const props = useDefaultizedDateRangeFieldProps(inProps);
  const {
    forwardedProps,
    internalProps
  } = splitFieldInternalAndForwardedProps(props, "date");
  return useField({
    inputRef,
    forwardedProps,
    internalProps,
    valueManager: rangeValueManager,
    fieldValueManager: rangeFieldValueManager,
    validator: validateDateRange,
    valueType: "date"
  });
};

export {
  rangeValueManager,
  isRangeValid,
  isWithinRange,
  isStartOfRange,
  isEndOfRange,
  validateDateRange,
  useDefaultizedDateRangeFieldProps,
  useSingleInputDateRangeField
};
//# sourceMappingURL=chunk-4KF54WAV.js.map
