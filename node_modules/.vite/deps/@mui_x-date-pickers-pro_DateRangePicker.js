import {
  PickersCalendarHeader,
  useDateField
} from "./chunk-HISFJY24.js";
import {
  isEndOfRange,
  isRangeValid,
  isStartOfRange,
  isWithinRange,
  rangeValueManager,
  useDefaultizedDateRangeFieldProps,
  validateDateRange
} from "./chunk-ITXMGNKQ.js";
import {
  DAY_MARGIN,
  DEFAULT_DESKTOP_MODE_MEDIA_QUERY,
  DayCalendar,
  PickersArrowSwitcher,
  PickersDay,
  PickersLayout,
  PickersModalDialog,
  PickersPopper,
  PickersToolbar,
  PickersToolbarButton,
  applyDefaultDate,
  executeInTheNextEventLoopTick,
  extractValidationProps,
  getActiveElement,
  onSpaceOrEnter,
  splitFieldInternalAndForwardedProps,
  uncapitalizeObjectKeys,
  useCalendarState,
  useControlledValueWithTimezone,
  useDefaultDates,
  useDefaultReduceAnimations,
  useLocaleText,
  useLocalizationContext,
  useNextMonthDisabled,
  useNow,
  usePicker,
  usePreviousMonthDisabled,
  useUtils,
  useValidation
} from "./chunk-LYJDPMCZ.js";
import {
  LocalizationProvider
} from "./chunk-A7A73IF3.js";
import {
  buildWarning
} from "./chunk-RW3DMCEO.js";
import {
  useMediaQuery
} from "./chunk-HQGVIIKC.js";
import "./chunk-MFQF2YHU.js";
import {
  TextField_default
} from "./chunk-SJWXYALB.js";
import "./chunk-KR5DFPDH.js";
import "./chunk-4D4IW64P.js";
import "./chunk-VDVKJJSE.js";
import "./chunk-KUMZN7VW.js";
import "./chunk-BJEY5R6A.js";
import "./chunk-PXUVGKQX.js";
import "./chunk-5FGLE7MA.js";
import "./chunk-J26ER5JI.js";
import "./chunk-SKJJLELE.js";
import "./chunk-KUMOFRTH.js";
import {
  resolveComponentProps,
  useSlotProps
} from "./chunk-3MHUBYUB.js";
import {
  Stack_default
} from "./chunk-OECFN7WO.js";
import {
  Typography_default
} from "./chunk-64MPCV3B.js";
import "./chunk-AC7LOWXL.js";
import "./chunk-AKKANAVW.js";
import "./chunk-PR6ZCO7G.js";
import "./chunk-RWNNQZB4.js";
import "./chunk-THDRPXEW.js";
import "./chunk-TJ4WWSAQ.js";
import "./chunk-AFACOYDU.js";
import "./chunk-PREV4HN6.js";
import "./chunk-FMFFUJ5P.js";
import "./chunk-STB3XA53.js";
import "./chunk-ASRPTVLX.js";
import "./chunk-SB5I2NHI.js";
import "./chunk-IAQNZBTL.js";
import "./chunk-ZW7WJ6XU.js";
import "./chunk-CPPBY4KB.js";
import "./chunk-CUQKQCWB.js";
import "./chunk-OAIYLAXU.js";
import "./chunk-FQP5XOQ3.js";
import "./chunk-CYQFAEQF.js";
import "./chunk-4Z5LHE24.js";
import "./chunk-YHVRRNWQ.js";
import "./chunk-4XSZJYXI.js";
import "./chunk-WMR7JIS2.js";
import "./chunk-5QYHYDG7.js";
import "./chunk-UACKSCCC.js";
import "./chunk-LDKVQR7Y.js";
import {
  styled_default
} from "./chunk-DOQN5XET.js";
import {
  useThemeProps
} from "./chunk-YT7MZJ5J.js";
import {
  _objectWithoutPropertiesLoose,
  alpha,
  clsx_default,
  composeClasses,
  generateUtilityClass,
  generateUtilityClasses,
  init_clsx,
  init_esm,
  init_objectWithoutPropertiesLoose,
  init_useControlled,
  init_useEventCallback,
  init_useForkRef,
  init_useId,
  ponyfillGlobal_default,
  refType_default,
  useControlled,
  useEventCallback_default,
  useForkRef,
  useId
} from "./chunk-RMM4FARM.js";
import {
  require_prop_types
} from "./chunk-WX4KK3LC.js";
import {
  _extends,
  init_extends
} from "./chunk-ZW3DX352.js";
import {
  require_jsx_runtime
} from "./chunk-DT77FM6J.js";
import {
  require_react
} from "./chunk-4D5CYJYK.js";
import {
  __toESM
} from "./chunk-CEQRFMJQ.js";

// node_modules/@mui/x-date-pickers-pro/DateRangePicker/DateRangePicker.js
init_extends();
init_objectWithoutPropertiesLoose();
var React18 = __toESM(require_react());
var import_prop_types7 = __toESM(require_prop_types());
init_esm();

// node_modules/@mui/x-date-pickers-pro/DesktopDateRangePicker/DesktopDateRangePicker.js
init_extends();
var React15 = __toESM(require_react());
var import_prop_types5 = __toESM(require_prop_types());
init_esm();

// node_modules/@mui/x-date-pickers-pro/DateRangePicker/shared.js
init_extends();
init_objectWithoutPropertiesLoose();
var React2 = __toESM(require_react());

// node_modules/@mui/x-date-pickers-pro/DateRangePicker/DateRangePickerToolbar.js
init_extends();
init_objectWithoutPropertiesLoose();
var React = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
init_clsx();
init_esm();

// node_modules/@mui/x-date-pickers-pro/DateRangePicker/dateRangePickerToolbarClasses.js
init_esm();
function getDateRangePickerToolbarUtilityClass(slot) {
  return generateUtilityClass("MuiDateRangePickerToolbar", slot);
}
var dateRangePickerToolbarClasses = generateUtilityClasses("MuiDateRangePickerToolbar", ["root", "container"]);

// node_modules/@mui/x-date-pickers-pro/DateRangePicker/DateRangePickerToolbar.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var _excluded = ["value", "rangePosition", "onRangePositionChange", "toolbarFormat", "className"];
var useUtilityClasses = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    container: ["container"]
  };
  return composeClasses(slots, getDateRangePickerToolbarUtilityClass, classes);
};
var DateRangePickerToolbarRoot = styled_default(PickersToolbar, {
  name: "MuiDateRangePickerToolbar",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})({});
var DateRangePickerToolbarContainer = styled_default("div", {
  name: "MuiDateRangePickerToolbar",
  slot: "Container",
  overridesResolver: (_, styles) => styles.container
})({
  display: "flex"
});
var DateRangePickerToolbar = React.forwardRef(function DateRangePickerToolbar2(inProps, ref) {
  const utils = useUtils();
  const props = useThemeProps({
    props: inProps,
    name: "MuiDateRangePickerToolbar"
  });
  const {
    value: [start, end],
    rangePosition,
    onRangePositionChange,
    toolbarFormat,
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded);
  const localeText = useLocaleText();
  const startDateValue = start ? utils.formatByString(start, toolbarFormat || utils.formats.shortDate) : localeText.start;
  const endDateValue = end ? utils.formatByString(end, toolbarFormat || utils.formats.shortDate) : localeText.end;
  const ownerState = props;
  const classes = useUtilityClasses(ownerState);
  return (0, import_jsx_runtime.jsx)(DateRangePickerToolbarRoot, _extends({}, other, {
    toolbarTitle: localeText.dateRangePickerToolbarTitle,
    isLandscape: false,
    className: clsx_default(className, classes.root),
    ownerState,
    ref,
    children: (0, import_jsx_runtime2.jsxs)(DateRangePickerToolbarContainer, {
      className: classes.container,
      children: [(0, import_jsx_runtime.jsx)(PickersToolbarButton, {
        variant: start !== null ? "h5" : "h6",
        value: startDateValue,
        selected: rangePosition === "start",
        onClick: () => onRangePositionChange("start")
      }), (0, import_jsx_runtime2.jsxs)(Typography_default, {
        variant: "h5",
        children: [" ", "–", " "]
      }), (0, import_jsx_runtime.jsx)(PickersToolbarButton, {
        variant: end !== null ? "h5" : "h6",
        value: endDateValue,
        selected: rangePosition === "end",
        onClick: () => onRangePositionChange("end")
      })]
    })
  }));
});
true ? DateRangePickerToolbar.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types.default.object,
  /**
   * className applied to the root component.
   */
  className: import_prop_types.default.string,
  disabled: import_prop_types.default.bool,
  /**
   * If `true`, show the toolbar even in desktop mode.
   * @default `true` for Desktop, `false` for Mobile.
   */
  hidden: import_prop_types.default.bool,
  onRangePositionChange: import_prop_types.default.func.isRequired,
  rangePosition: import_prop_types.default.oneOf(["end", "start"]).isRequired,
  readOnly: import_prop_types.default.bool,
  sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object]),
  titleId: import_prop_types.default.string,
  /**
   * Toolbar date format.
   */
  toolbarFormat: import_prop_types.default.string,
  /**
   * Toolbar value placeholder—it is displayed when the value is empty.
   * @default "––"
   */
  toolbarPlaceholder: import_prop_types.default.node,
  value: import_prop_types.default.arrayOf(import_prop_types.default.any).isRequired
} : void 0;

// node_modules/@mui/x-date-pickers-pro/DateRangePicker/shared.js
var _excluded2 = ["components", "componentsProps"];
function useDateRangePickerDefaultizedProps(props, name) {
  var _themeProps$disableFu, _themeProps$disablePa, _themeProps$slots, _themeProps$slotProps;
  const utils = useUtils();
  const defaultDates = useDefaultDates();
  const _useThemeProps = useThemeProps({
    props,
    name
  }), {
    components,
    componentsProps
  } = _useThemeProps, themeProps = _objectWithoutPropertiesLoose(_useThemeProps, _excluded2);
  const localeText = React2.useMemo(() => {
    var _themeProps$localeTex;
    if (((_themeProps$localeTex = themeProps.localeText) == null ? void 0 : _themeProps$localeTex.toolbarTitle) == null) {
      return themeProps.localeText;
    }
    return _extends({}, themeProps.localeText, {
      dateRangePickerToolbarTitle: themeProps.localeText.toolbarTitle
    });
  }, [themeProps.localeText]);
  return _extends({}, themeProps, {
    localeText,
    disableFuture: (_themeProps$disableFu = themeProps.disableFuture) != null ? _themeProps$disableFu : false,
    disablePast: (_themeProps$disablePa = themeProps.disablePast) != null ? _themeProps$disablePa : false,
    minDate: applyDefaultDate(utils, themeProps.minDate, defaultDates.minDate),
    maxDate: applyDefaultDate(utils, themeProps.maxDate, defaultDates.maxDate),
    slots: _extends({
      toolbar: DateRangePickerToolbar
    }, (_themeProps$slots = themeProps.slots) != null ? _themeProps$slots : uncapitalizeObjectKeys(components)),
    slotProps: (_themeProps$slotProps = themeProps.slotProps) != null ? _themeProps$slotProps : componentsProps
  });
}

// node_modules/@mui/x-date-pickers-pro/dateRangeViewRenderers/dateRangeViewRenderers.js
var React11 = __toESM(require_react());

// node_modules/@mui/x-date-pickers-pro/DateRangeCalendar/DateRangeCalendar.js
init_objectWithoutPropertiesLoose();
init_extends();
var React10 = __toESM(require_react());
var import_prop_types3 = __toESM(require_prop_types());
init_clsx();
init_useEventCallback();
init_esm();

// node_modules/@mui/x-license-pro/encoding/md5.js
var k = [];
var i = 0;
for (; i < 64; ) {
  k[i] = 0 | Math.sin(++i % Math.PI) * 4294967296;
}
function md5(s) {
  const words = [];
  let b, c, d, j = unescape(encodeURI(s)) + "", a = j.length;
  const h = [b = 1732584193, c = 4023233417, ~b, ~c];
  s = --a / 4 + 2 | 15;
  words[--s] = a * 8;
  for (; ~a; ) {
    words[a >> 2] |= j.charCodeAt(a) << 8 * a--;
  }
  for (i = j = 0; i < s; i += 16) {
    a = h;
    for (; j < 64; a = [d = a[3], b + ((d = a[0] + [b & c | ~b & d, d & b | ~d & c, b ^ c ^ d, c ^ (b | ~d)][a = j >> 4] + k[j] + ~~words[i | [j, 5 * j + 1, 3 * j + 5, 7 * j][a] & 15]) << (a = [7, 12, 17, 22, 5, 9, 14, 20, 4, 11, 16, 23, 6, 10, 15, 21][4 * a + j++ % 4]) | d >>> -a), b, c]) {
      b = a[1] | 0;
      c = a[2];
    }
    for (j = 4; j; )
      h[--j] += a[j];
  }
  for (s = ""; j < 32; ) {
    s += (h[j >> 3] >> (1 ^ j++) * 4 & 15).toString(16);
  }
  return s;
}

// node_modules/@mui/x-license-pro/encoding/base64.js
var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var base64Decode = (input) => {
  let output = "";
  let chr1, chr2, chr3;
  let enc1, enc2, enc3, enc4;
  let i2 = 0;
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
  while (i2 < input.length) {
    enc1 = _keyStr.indexOf(input.charAt(i2++));
    enc2 = _keyStr.indexOf(input.charAt(i2++));
    enc3 = _keyStr.indexOf(input.charAt(i2++));
    enc4 = _keyStr.indexOf(input.charAt(i2++));
    chr1 = enc1 << 2 | enc2 >> 4;
    chr2 = (enc2 & 15) << 4 | enc3 >> 2;
    chr3 = (enc3 & 3) << 6 | enc4;
    output = output + String.fromCharCode(chr1);
    if (enc3 != 64) {
      output = output + String.fromCharCode(chr2);
    }
    if (enc4 != 64) {
      output = output + String.fromCharCode(chr3);
    }
  }
  return output;
};

// node_modules/@mui/x-license-pro/utils/licenseScope.js
var LICENSE_SCOPES = ["pro", "premium"];

// node_modules/@mui/x-license-pro/utils/licensingModel.js
var LICENSING_MODELS = [
  /**
   * A license is outdated if the current version of the software was released after the expiry date of the license.
   * But the license can be used indefinitely with an older version of the software.
   */
  "perpetual",
  /**
   * On development, a license is outdated if the expiry date has been reached
   * On production, a license is outdated if the current version of the software was released after the expiry date of the license (see "perpetual")
   */
  "annual",
  /**
   * TODO 2025 remove, legacy name of annual.
   */
  "subscription"
];

// node_modules/@mui/x-license-pro/utils/licenseErrorMessageUtils.js
function showError(message) {
  console.error(["*************************************************************", "", ...message, "", "*************************************************************"].join("\n"));
}
function showInvalidLicenseKeyError() {
  showError(["MUI: Invalid license key.", "", "Your MUI X license key format isn't valid. It could be because the license key is missing a character or has a typo.", "", "To solve the issue, you need to double check that `setLicenseKey()` is called with the right argument", "Please check the license key installation https://mui.com/r/x-license-key-installation."]);
}
function showLicenseKeyPlanMismatchError() {
  showError(["MUI: License key plan mismatch.", "", "Your use of MUI X is not compatible with the plan of your license key. The feature you are trying to use is not included in the plan of your license key. This happens if you try to use `DataGridPremium` with a license key for the Pro plan.", "", "To solve the issue, you can upgrade your plan from Pro to Premium at https://mui.com/r/x-get-license?scope=premium.", "Of if you didn't intend to use Premium features, you can replace the import of `@mui/x-data-grid-premium` with `@mui/x-data-grid-pro`."]);
}
function showMissingLicenseKeyError({
  plan,
  packageName
}) {
  showError(["MUI: Missing license key.", "", `The license key is missing. You might not be allowed to use \`${packageName}\` which is part of MUI X ${plan}.`, "", "To solve the issue, you can check the free trial conditions: https://mui.com/r/x-license-trial.", "If you are eligible no actions are required. If you are not eligible to the free trial, you need to purchase a license https://mui.com/r/x-get-license or stop using the software immediately."]);
}
function showExpiredPackageVersionError({
  packageName
}) {
  showError(["MUI: Expired package version.", "", `You have installed a version of \`${packageName}\` that is outside of the maintenance plan of your license key. By default, commercial licenses provide access to new versions released during the first year after the purchase.`, "", "To solve the issue, you can renew your license https://mui.com/r/x-get-license or install an older version of the npm package that is compatible with your license key."]);
}
function showExpiredAnnualGraceLicenseKeyError({
  plan,
  licenseKey,
  expiryTimestamp
}) {
  showError(["MUI: Expired license key.", "", `Your annual license key to use MUI X ${plan}'s on non-production environments is expired. If you are seeing this development console message, you might be close to breach the license terms by making direct or indirect changes to the frontend of an app that render a MUI X ${plan} component (more details in https://mui.com/r/x-license-annual).`, "", "To solve the problem you can either:", "", "- Renew your license https://mui.com/r/x-get-license and use the new key", `- Stop making changes to code depending directly or indirectly on MUI X ${plan}'s APIs`, "", "Note that your license is perpetual in production environments with any version released before your license term ends.", "", `- License key expiry timestamp: ${new Date(expiryTimestamp)}`, `- Installed license key: ${licenseKey}`, ""]);
}
function showExpiredAnnualLicenseKeyError({
  plan,
  licenseKey,
  expiryTimestamp
}) {
  throw new Error(["MUI: Expired license key.", "", `Your annual license key to use MUI X ${plan}'s on non-production environments is expired. If you are seeing this development console message, you might be close to breach the license terms by making direct or indirect changes to the frontend of an app that render a MUI X ${plan} component (more details in https://mui.com/r/x-license-annual).`, "", "To solve the problem you can either:", "", "- Renew your license https://mui.com/r/x-get-license and use the new key", `- Stop making changes to code depending directly or indirectly on MUI X ${plan}'s APIs`, "", "Note that your license is perpetual in production environments with any version released before your license term ends.", "", `- License key expiry timestamp: ${new Date(expiryTimestamp)}`, `- Installed license key: ${licenseKey}`, ""].join("\n"));
}

// node_modules/@mui/x-license-pro/utils/licenseInfo.js
init_esm();
ponyfillGlobal_default.__MUI_LICENSE_INFO__ = ponyfillGlobal_default.__MUI_LICENSE_INFO__ || {
  key: void 0
};
var LicenseInfo = class _LicenseInfo {
  static getLicenseInfo() {
    return ponyfillGlobal_default.__MUI_LICENSE_INFO__;
  }
  static getLicenseKey() {
    return _LicenseInfo.getLicenseInfo().key;
  }
  static setLicenseKey(key) {
    const licenseInfo = _LicenseInfo.getLicenseInfo();
    licenseInfo.key = key;
  }
};

// node_modules/@mui/x-license-pro/utils/licenseStatus.js
var LICENSE_STATUS = function(LICENSE_STATUS2) {
  LICENSE_STATUS2["NotFound"] = "NotFound";
  LICENSE_STATUS2["Invalid"] = "Invalid";
  LICENSE_STATUS2["ExpiredAnnual"] = "ExpiredAnnual";
  LICENSE_STATUS2["ExpiredAnnualGrace"] = "ExpiredAnnualGrace";
  LICENSE_STATUS2["ExpiredVersion"] = "ExpiredVersion";
  LICENSE_STATUS2["Valid"] = "Valid";
  LICENSE_STATUS2["OutOfScope"] = "OutOfScope";
  return LICENSE_STATUS2;
}({});

// node_modules/@mui/x-license-pro/verifyLicense/verifyLicense.js
var expiryReg = /^.*EXPIRY=([0-9]+),.*$/;
var decodeLicenseVersion1 = (license) => {
  let expiryTimestamp;
  try {
    expiryTimestamp = parseInt(license.match(expiryReg)[1], 10);
    if (!expiryTimestamp || Number.isNaN(expiryTimestamp)) {
      expiryTimestamp = null;
    }
  } catch (err) {
    expiryTimestamp = null;
  }
  return {
    scope: "pro",
    licensingModel: "perpetual",
    expiryTimestamp
  };
};
var decodeLicenseVersion2 = (license) => {
  const licenseInfo = {
    scope: null,
    licensingModel: null,
    expiryTimestamp: null
  };
  license.split(",").map((token) => token.split("=")).filter((el) => el.length === 2).forEach(([key, value]) => {
    if (key === "S") {
      licenseInfo.scope = value;
    }
    if (key === "LM") {
      licenseInfo.licensingModel = value;
    }
    if (key === "E") {
      const expiryTimestamp = parseInt(value, 10);
      if (expiryTimestamp && !Number.isNaN(expiryTimestamp)) {
        licenseInfo.expiryTimestamp = expiryTimestamp;
      }
    }
  });
  return licenseInfo;
};
var decodeLicense = (encodedLicense) => {
  const license = base64Decode(encodedLicense);
  if (license.includes("KEYVERSION=1")) {
    return decodeLicenseVersion1(license);
  }
  if (license.includes("KV=2")) {
    return decodeLicenseVersion2(license);
  }
  return null;
};
function verifyLicense({
  releaseInfo: releaseInfo5,
  licenseKey,
  acceptedScopes
}) {
  if (!releaseInfo5) {
    throw new Error("MUI: The release information is missing. Not able to validate license.");
  }
  if (!licenseKey) {
    return {
      status: LICENSE_STATUS.NotFound
    };
  }
  const hash = licenseKey.substr(0, 32);
  const encoded = licenseKey.substr(32);
  if (hash !== md5(encoded)) {
    return {
      status: LICENSE_STATUS.Invalid
    };
  }
  const license = decodeLicense(encoded);
  if (license == null) {
    console.error("Error checking license. Key version not found!");
    return {
      status: LICENSE_STATUS.Invalid
    };
  }
  if (license.licensingModel == null || !LICENSING_MODELS.includes(license.licensingModel)) {
    console.error("Error checking license. Licensing model not found or invalid!");
    return {
      status: LICENSE_STATUS.Invalid
    };
  }
  if (license.expiryTimestamp == null) {
    console.error("Error checking license. Expiry timestamp not found or invalid!");
    return {
      status: LICENSE_STATUS.Invalid
    };
  }
  if (license.licensingModel === "perpetual" || false) {
    const pkgTimestamp = parseInt(base64Decode(releaseInfo5), 10);
    if (Number.isNaN(pkgTimestamp)) {
      throw new Error("MUI: The release information is invalid. Not able to validate license.");
    }
    if (license.expiryTimestamp < pkgTimestamp) {
      return {
        status: LICENSE_STATUS.ExpiredVersion
      };
    }
  } else if (license.licensingModel === "subscription" || license.licensingModel === "annual") {
    if ((/* @__PURE__ */ new Date()).getTime() > license.expiryTimestamp) {
      if (
        // 30 days grace
        (/* @__PURE__ */ new Date()).getTime() < license.expiryTimestamp + 1e3 * 3600 * 24 * 30 || false
      ) {
        return {
          status: LICENSE_STATUS.ExpiredAnnualGrace,
          meta: {
            expiryTimestamp: license.expiryTimestamp,
            licenseKey
          }
        };
      }
      return {
        status: LICENSE_STATUS.ExpiredAnnual,
        meta: {
          expiryTimestamp: license.expiryTimestamp,
          licenseKey
        }
      };
    }
  }
  if (license.scope == null || !LICENSE_SCOPES.includes(license.scope)) {
    console.error("Error checking license. scope not found or invalid!");
    return {
      status: LICENSE_STATUS.Invalid
    };
  }
  if (!acceptedScopes.includes(license.scope)) {
    return {
      status: LICENSE_STATUS.OutOfScope
    };
  }
  return {
    status: LICENSE_STATUS.Valid
  };
}

// node_modules/@mui/x-license-pro/useLicenseVerifier/useLicenseVerifier.js
init_extends();
var React4 = __toESM(require_react());

// node_modules/@mui/x-license-pro/Unstable_LicenseInfoProvider/LicenseInfoContext.js
var React3 = __toESM(require_react());
var LicenseInfoContext_default = React3.createContext({
  key: void 0
});

// node_modules/@mui/x-license-pro/useLicenseVerifier/useLicenseVerifier.js
var sharedLicenseStatuses = {};
function useLicenseVerifier(packageName, releaseInfo5) {
  const {
    key: contextKey
  } = React4.useContext(LicenseInfoContext_default);
  return React4.useMemo(() => {
    const licenseKey = contextKey != null ? contextKey : LicenseInfo.getLicenseKey();
    if (sharedLicenseStatuses[packageName] && sharedLicenseStatuses[packageName].key === licenseKey) {
      return sharedLicenseStatuses[packageName].licenseVerifier;
    }
    const acceptedScopes = packageName.includes("premium") ? ["premium"] : ["pro", "premium"];
    const plan = packageName.includes("premium") ? "Premium" : "Pro";
    const licenseStatus = verifyLicense({
      releaseInfo: releaseInfo5,
      licenseKey,
      acceptedScopes
    });
    sharedLicenseStatuses[packageName] = {
      key: licenseKey,
      licenseVerifier: licenseStatus
    };
    const fullPackageName = `@mui/${packageName}`;
    if (licenseStatus.status === LICENSE_STATUS.Valid) {
    } else if (licenseStatus.status === LICENSE_STATUS.Invalid) {
      showInvalidLicenseKeyError();
    } else if (licenseStatus.status === LICENSE_STATUS.OutOfScope) {
      showLicenseKeyPlanMismatchError();
    } else if (licenseStatus.status === LICENSE_STATUS.NotFound) {
      showMissingLicenseKeyError({
        plan,
        packageName: fullPackageName
      });
    } else if (licenseStatus.status === LICENSE_STATUS.ExpiredAnnualGrace) {
      showExpiredAnnualGraceLicenseKeyError(_extends({
        plan
      }, licenseStatus.meta));
    } else if (licenseStatus.status === LICENSE_STATUS.ExpiredAnnual) {
      showExpiredAnnualLicenseKeyError(_extends({
        plan
      }, licenseStatus.meta));
    } else if (licenseStatus.status === LICENSE_STATUS.ExpiredVersion) {
      showExpiredPackageVersionError({
        packageName: fullPackageName
      });
    } else if (true) {
      throw new Error("missing status handler");
    }
    return licenseStatus;
  }, [packageName, releaseInfo5, contextKey]);
}

// node_modules/@mui/x-license-pro/Watermark/Watermark.js
var React5 = __toESM(require_react());
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
function getLicenseErrorMessage(licenseStatus) {
  switch (licenseStatus) {
    case LICENSE_STATUS.ExpiredAnnualGrace:
    case LICENSE_STATUS.ExpiredAnnual:
      return "MUI X Expired license key";
    case LICENSE_STATUS.ExpiredVersion:
      return "MUI X Expired package version";
    case LICENSE_STATUS.Invalid:
      return "MUI X Invalid license key";
    case LICENSE_STATUS.OutOfScope:
      return "MUI X License key plan mismatch";
    case LICENSE_STATUS.NotFound:
      return "MUI X Missing license key";
    default:
      throw new Error("MUI: Unhandled MUI X license status.");
  }
}
function Watermark(props) {
  const {
    packageName,
    releaseInfo: releaseInfo5
  } = props;
  const licenseStatus = useLicenseVerifier(packageName, releaseInfo5);
  if (licenseStatus.status === LICENSE_STATUS.Valid) {
    return null;
  }
  return (0, import_jsx_runtime3.jsx)("div", {
    style: {
      position: "absolute",
      pointerEvents: "none",
      color: "#8282829e",
      zIndex: 1e5,
      width: "100%",
      textAlign: "center",
      bottom: "50%",
      right: 0,
      letterSpacing: 5,
      fontSize: 24
    },
    children: getLicenseErrorMessage(licenseStatus.status)
  });
}

// node_modules/@mui/x-license-pro/Unstable_LicenseInfoProvider/LicenseInfoProvider.js
var React6 = __toESM(require_react());
var import_jsx_runtime4 = __toESM(require_jsx_runtime());

// node_modules/@mui/x-date-pickers-pro/internals/utils/releaseInfo.js
init_esm();
var getReleaseInfo = () => {
  const releaseInfo5 = "MTcwMjQ5NDAwMDAwMA==";
  if (true) {
    if (releaseInfo5 === "__RELEASE_INFO__") {
      return ponyfillGlobal_default.__MUI_RELEASE_INFO__;
    }
  }
  return releaseInfo5;
};

// node_modules/@mui/x-date-pickers-pro/DateRangeCalendar/dateRangeCalendarClasses.js
init_esm();
var getDateRangeCalendarUtilityClass = (slot) => generateUtilityClass("MuiDateRangeCalendar", slot);
var dateRangeCalendarClasses = generateUtilityClasses("MuiDateRangeCalendar", ["root", "monthContainer", "dayDragging"]);

// node_modules/@mui/x-date-pickers-pro/internals/utils/date-range-manager.js
function calculateRangeChange({
  utils,
  range,
  newDate: selectedDate,
  rangePosition,
  allowRangeFlip = false
}) {
  const [start, end] = range;
  if (rangePosition === "start") {
    const truthyResult2 = allowRangeFlip ? {
      nextSelection: "start",
      newRange: [end, selectedDate]
    } : {
      nextSelection: "end",
      newRange: [selectedDate, null]
    };
    return Boolean(end) && utils.isAfter(selectedDate, end) ? truthyResult2 : {
      nextSelection: "end",
      newRange: [selectedDate, end]
    };
  }
  const truthyResult = allowRangeFlip ? {
    nextSelection: "end",
    newRange: [selectedDate, start]
  } : {
    nextSelection: "end",
    newRange: [selectedDate, null]
  };
  return Boolean(start) && utils.isBefore(selectedDate, start) ? truthyResult : {
    nextSelection: "start",
    newRange: [start, selectedDate]
  };
}
function calculateRangePreview(options) {
  if (options.newDate == null) {
    return [null, null];
  }
  const [start, end] = options.range;
  const {
    newRange
  } = calculateRangeChange(options);
  if (!start || !end) {
    return newRange;
  }
  const [previewStart, previewEnd] = newRange;
  return options.rangePosition === "end" ? [end, previewEnd] : [previewStart, start];
}

// node_modules/@mui/x-date-pickers-pro/DateRangePickerDay/DateRangePickerDay.js
init_objectWithoutPropertiesLoose();
init_extends();
var React7 = __toESM(require_react());
var import_prop_types2 = __toESM(require_prop_types());
init_clsx();
init_esm();

// node_modules/@mui/x-date-pickers-pro/DateRangePickerDay/dateRangePickerDayClasses.js
init_esm();
function getDateRangePickerDayUtilityClass(slot) {
  return generateUtilityClass("MuiDateRangePickerDay", slot);
}
var dateRangePickerDayClasses = generateUtilityClasses("MuiDateRangePickerDay", ["root", "rangeIntervalDayHighlight", "rangeIntervalDayHighlightStart", "rangeIntervalDayHighlightEnd", "rangeIntervalPreview", "rangeIntervalDayPreview", "rangeIntervalDayPreviewStart", "rangeIntervalDayPreviewEnd", "outsideCurrentMonth", "startOfMonth", "endOfMonth", "firstVisibleCell", "lastVisibleCell", "hiddenDayFiller", "day", "dayOutsideRangeInterval", "dayInsideRangeInterval", "notSelectedDate"]);

// node_modules/@mui/x-date-pickers-pro/DateRangePickerDay/DateRangePickerDay.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var _excluded3 = ["className", "day", "outsideCurrentMonth", "isEndOfHighlighting", "isEndOfPreviewing", "isHighlighting", "isPreviewing", "isStartOfHighlighting", "isStartOfPreviewing", "selected", "isVisuallySelected", "sx", "draggable", "isFirstVisibleCell", "isLastVisibleCell"];
var releaseInfo = getReleaseInfo();
var useUtilityClasses2 = (ownerState) => {
  const {
    isHighlighting,
    outsideCurrentMonth,
    isStartOfHighlighting,
    isStartOfMonth,
    isEndOfHighlighting,
    isEndOfMonth,
    isPreviewing,
    isStartOfPreviewing,
    isEndOfPreviewing,
    isFirstVisibleCell,
    isLastVisibleCell,
    isHiddenDayFiller,
    selected,
    classes
  } = ownerState;
  const slots = {
    root: ["root", isHighlighting && "rangeIntervalDayHighlight", isStartOfHighlighting && "rangeIntervalDayHighlightStart", isEndOfHighlighting && "rangeIntervalDayHighlightEnd", outsideCurrentMonth && "outsideCurrentMonth", isStartOfMonth && "startOfMonth", isEndOfMonth && "endOfMonth", isFirstVisibleCell && "firstVisibleCell", isLastVisibleCell && "lastVisibleCell", isHiddenDayFiller && "hiddenDayFiller"],
    rangeIntervalPreview: ["rangeIntervalPreview", isPreviewing && "rangeIntervalDayPreview", (isStartOfPreviewing || isStartOfMonth) && "rangeIntervalDayPreviewStart", (isEndOfPreviewing || isEndOfMonth) && "rangeIntervalDayPreviewEnd"],
    day: ["day", !selected && "notSelectedDate", !isHighlighting && "dayOutsideRangeInterval", !selected && isHighlighting && "dayInsideRangeInterval"]
  };
  return composeClasses(slots, getDateRangePickerDayUtilityClass, classes);
};
var endBorderStyle = {
  borderTopRightRadius: "50%",
  borderBottomRightRadius: "50%"
};
var startBorderStyle = {
  borderTopLeftRadius: "50%",
  borderBottomLeftRadius: "50%"
};
var DateRangePickerDayRoot = styled_default("div", {
  name: "MuiDateRangePickerDay",
  slot: "Root",
  overridesResolver: (_, styles) => [{
    [`&.${dateRangePickerDayClasses.rangeIntervalDayHighlight}`]: styles.rangeIntervalDayHighlight
  }, {
    [`&.${dateRangePickerDayClasses.rangeIntervalDayHighlightStart}`]: styles.rangeIntervalDayHighlightStart
  }, {
    [`&.${dateRangePickerDayClasses.rangeIntervalDayHighlightEnd}`]: styles.rangeIntervalDayHighlightEnd
  }, {
    [`&.${dateRangePickerDayClasses.firstVisibleCell}`]: styles.firstVisibleCell
  }, {
    [`&.${dateRangePickerDayClasses.lastVisibleCell}`]: styles.lastVisibleCell
  }, {
    [`&.${dateRangePickerDayClasses.startOfMonth}`]: styles.startOfMonth
  }, {
    [`&.${dateRangePickerDayClasses.endOfMonth}`]: styles.endOfMonth
  }, {
    [`&.${dateRangePickerDayClasses.outsideCurrentMonth}`]: styles.outsideCurrentMonth
  }, {
    [`&.${dateRangePickerDayClasses.hiddenDayFiller}`]: styles.hiddenDayFiller
  }, styles.root]
})(({
  theme,
  ownerState
}) => ownerState.isHiddenDayFiller ? {} : _extends({
  [`&:first-of-type .${dateRangePickerDayClasses.rangeIntervalDayPreview}`]: _extends({}, startBorderStyle, {
    borderLeftColor: (theme.vars || theme).palette.divider
  }),
  [`&:last-of-type .${dateRangePickerDayClasses.rangeIntervalDayPreview}`]: _extends({}, endBorderStyle, {
    borderRightColor: (theme.vars || theme).palette.divider
  })
}, ownerState.isHighlighting && {
  borderRadius: 0,
  color: (theme.vars || theme).palette.primary.contrastText,
  backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.focusOpacity),
  "&:first-of-type": startBorderStyle,
  "&:last-of-type": endBorderStyle
}, (ownerState.isStartOfHighlighting || ownerState.isFirstVisibleCell) && _extends({}, startBorderStyle, {
  paddingLeft: 0
}), (ownerState.isEndOfHighlighting || ownerState.isLastVisibleCell) && _extends({}, endBorderStyle, {
  paddingRight: 0
})));
DateRangePickerDayRoot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  ownerState: import_prop_types2.default.object.isRequired
};
var DateRangePickerDayRangeIntervalPreview = styled_default("div", {
  name: "MuiDateRangePickerDay",
  slot: "RangeIntervalPreview",
  overridesResolver: (_, styles) => [{
    [`&.${dateRangePickerDayClasses.rangeIntervalDayPreview}`]: styles.rangeIntervalDayPreview
  }, {
    [`&.${dateRangePickerDayClasses.rangeIntervalDayPreviewStart}`]: styles.rangeIntervalDayPreviewStart
  }, {
    [`&.${dateRangePickerDayClasses.rangeIntervalDayPreviewEnd}`]: styles.rangeIntervalDayPreviewEnd
  }, styles.rangeIntervalPreview]
})(({
  theme,
  ownerState
}) => _extends({
  // replace default day component margin with transparent border to avoid jumping on preview
  border: "2px solid transparent"
}, ownerState.isPreviewing && !ownerState.isHiddenDayFiller && _extends({
  borderRadius: 0,
  border: `2px dashed ${(theme.vars || theme).palette.divider}`,
  borderLeftColor: "transparent",
  borderRightColor: "transparent"
}, (ownerState.isStartOfPreviewing || ownerState.isFirstVisibleCell) && _extends({
  borderLeftColor: (theme.vars || theme).palette.divider
}, startBorderStyle), (ownerState.isEndOfPreviewing || ownerState.isLastVisibleCell) && _extends({
  borderRightColor: (theme.vars || theme).palette.divider
}, endBorderStyle))));
DateRangePickerDayRangeIntervalPreview.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  ownerState: import_prop_types2.default.object.isRequired
};
var DateRangePickerDayDay = styled_default(PickersDay, {
  name: "MuiDateRangePickerDay",
  slot: "Day",
  overridesResolver: (_, styles) => [{
    [`&.${dateRangePickerDayClasses.dayInsideRangeInterval}`]: styles.dayInsideRangeInterval
  }, {
    [`&.${dateRangePickerDayClasses.dayOutsideRangeInterval}`]: styles.dayOutsideRangeInterval
  }, {
    [`&.${dateRangePickerDayClasses.notSelectedDate}`]: styles.notSelectedDate
  }, styles.day]
})(({
  ownerState
}) => _extends({
  // Required to overlap preview border
  transform: "scale(1.1)",
  "& > *": {
    transform: "scale(0.9)"
  }
}, ownerState.draggable && {
  cursor: "grab"
}, ownerState.draggable && {
  touchAction: "none"
}));
var DateRangePickerDayRaw = React7.forwardRef(function DateRangePickerDay(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDateRangePickerDay"
  });
  const {
    className,
    day,
    outsideCurrentMonth,
    isHighlighting,
    isPreviewing,
    selected = false,
    isVisuallySelected,
    sx,
    draggable,
    isFirstVisibleCell,
    isLastVisibleCell
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded3);
  useLicenseVerifier("x-date-pickers-pro", releaseInfo);
  const utils = useUtils();
  const isEndOfMonth = utils.isSameDay(day, utils.endOfMonth(day));
  const isStartOfMonth = utils.isSameDay(day, utils.startOfMonth(day));
  const shouldRenderHighlight = isHighlighting && !outsideCurrentMonth;
  const shouldRenderPreview = isPreviewing && !outsideCurrentMonth;
  const ownerState = _extends({}, props, {
    selected,
    isStartOfMonth,
    isEndOfMonth,
    draggable,
    isFirstVisibleCell,
    isLastVisibleCell,
    isHiddenDayFiller: outsideCurrentMonth && !other.showDaysOutsideCurrentMonth
  });
  const classes = useUtilityClasses2(ownerState);
  return (0, import_jsx_runtime5.jsx)(DateRangePickerDayRoot, {
    className: clsx_default(classes.root, className),
    ownerState,
    sx,
    children: (0, import_jsx_runtime5.jsx)(DateRangePickerDayRangeIntervalPreview, {
      className: classes.rangeIntervalPreview,
      ownerState,
      children: (0, import_jsx_runtime5.jsx)(DateRangePickerDayDay, _extends({}, other, {
        ref,
        disableMargin: true,
        day,
        selected: isVisuallySelected,
        outsideCurrentMonth,
        className: classes.day,
        ownerState,
        draggable,
        isFirstVisibleCell,
        isLastVisibleCell
      }))
    })
  });
});
true ? DateRangePickerDayRaw.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * A ref for imperative actions.
   * It currently only supports `focusVisible()` action.
   */
  action: import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.shape({
    current: import_prop_types2.default.shape({
      focusVisible: import_prop_types2.default.func.isRequired
    })
  })]),
  /**
   * If `true`, the ripples are centered.
   * They won't start at the cursor interaction position.
   * @default false
   */
  centerRipple: import_prop_types2.default.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types2.default.object,
  className: import_prop_types2.default.string,
  component: import_prop_types2.default.elementType,
  /**
   * The date to show.
   */
  day: import_prop_types2.default.any.isRequired,
  /**
   * If `true`, renders as disabled.
   * @default false
   */
  disabled: import_prop_types2.default.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: import_prop_types2.default.bool,
  /**
   * If `true`, days are rendering without margin. Useful for displaying linked range of days.
   * @default false
   */
  disableMargin: import_prop_types2.default.bool,
  /**
   * If `true`, the ripple effect is disabled.
   *
   * ⚠️ Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
   * @default false
   */
  disableRipple: import_prop_types2.default.bool,
  /**
   * If `true`, the touch ripple effect is disabled.
   * @default false
   */
  disableTouchRipple: import_prop_types2.default.bool,
  /**
   * If `true`, the base button will have a keyboard focus ripple.
   * @default false
   */
  focusRipple: import_prop_types2.default.bool,
  /**
   * This prop can help identify which element has keyboard focus.
   * The class name will be applied when the element gains the focus through keyboard interaction.
   * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).
   * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/HEAD/explainer.md).
   * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components
   * if needed.
   */
  focusVisibleClassName: import_prop_types2.default.string,
  isAnimating: import_prop_types2.default.bool,
  /**
   * Set to `true` if the `day` is the end of a highlighted date range.
   */
  isEndOfHighlighting: import_prop_types2.default.bool.isRequired,
  /**
   * Set to `true` if the `day` is the end of a previewing date range.
   */
  isEndOfPreviewing: import_prop_types2.default.bool.isRequired,
  /**
   * If `true`, day is the first visible cell of the month.
   * Either the first day of the month or the first day of the week depending on `showDaysOutsideCurrentMonth`.
   */
  isFirstVisibleCell: import_prop_types2.default.bool.isRequired,
  /**
   * Set to `true` if the `day` is in a highlighted date range.
   */
  isHighlighting: import_prop_types2.default.bool.isRequired,
  /**
   * If `true`, day is the last visible cell of the month.
   * Either the last day of the month or the last day of the week depending on `showDaysOutsideCurrentMonth`.
   */
  isLastVisibleCell: import_prop_types2.default.bool.isRequired,
  /**
   * Set to `true` if the `day` is in a preview date range.
   */
  isPreviewing: import_prop_types2.default.bool.isRequired,
  /**
   * Set to `true` if the `day` is the start of a highlighted date range.
   */
  isStartOfHighlighting: import_prop_types2.default.bool.isRequired,
  /**
   * Set to `true` if the `day` is the start of a previewing date range.
   */
  isStartOfPreviewing: import_prop_types2.default.bool.isRequired,
  /**
   * Indicates if the day should be visually selected.
   */
  isVisuallySelected: import_prop_types2.default.bool,
  onDaySelect: import_prop_types2.default.func.isRequired,
  /**
   * Callback fired when the component is focused with a keyboard.
   * We trigger a `onFocus` callback too.
   */
  onFocusVisible: import_prop_types2.default.func,
  onMouseEnter: import_prop_types2.default.func,
  /**
   * If `true`, day is outside of month and will be hidden.
   */
  outsideCurrentMonth: import_prop_types2.default.bool.isRequired,
  /**
   * If `true`, renders as selected.
   * @default false
   */
  selected: import_prop_types2.default.bool,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: import_prop_types2.default.bool,
  style: import_prop_types2.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types2.default.oneOfType([import_prop_types2.default.arrayOf(import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.object, import_prop_types2.default.bool])), import_prop_types2.default.func, import_prop_types2.default.object]),
  /**
   * @default 0
   */
  tabIndex: import_prop_types2.default.number,
  /**
   * If `true`, renders as today date.
   * @default false
   */
  today: import_prop_types2.default.bool,
  /**
   * Props applied to the `TouchRipple` element.
   */
  TouchRippleProps: import_prop_types2.default.object,
  /**
   * A ref that points to the `TouchRipple` element.
   */
  touchRippleRef: import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.shape({
    current: import_prop_types2.default.shape({
      pulsate: import_prop_types2.default.func.isRequired,
      start: import_prop_types2.default.func.isRequired,
      stop: import_prop_types2.default.func.isRequired
    })
  })])
} : void 0;
var DateRangePickerDay2 = React7.memo(DateRangePickerDayRaw);

// node_modules/@mui/x-date-pickers-pro/DateRangeCalendar/useDragRange.js
init_extends();
var React8 = __toESM(require_react());
init_useEventCallback();
var resolveDateFromTarget = (target, utils, timezone) => {
  const timestampString = target.dataset.timestamp;
  if (!timestampString) {
    return null;
  }
  const timestamp = +timestampString;
  return utils.dateWithTimezone(new Date(timestamp).toISOString(), timezone);
};
var isSameAsDraggingDate = (event) => {
  const timestampString = event.target.dataset.timestamp;
  return timestampString === event.dataTransfer.getData("draggingDate");
};
var resolveButtonElement = (element) => {
  if (element) {
    if (element instanceof HTMLButtonElement && !element.disabled) {
      return element;
    }
    if (element.children.length) {
      return resolveButtonElement(element.children[0]);
    }
    return null;
  }
  return element;
};
var resolveElementFromTouch = (event, ignoreTouchTarget) => {
  var _event$changedTouches;
  if (((_event$changedTouches = event.changedTouches) == null ? void 0 : _event$changedTouches.length) === 1 && event.touches.length <= 1) {
    const element = document.elementFromPoint(event.changedTouches[0].clientX, event.changedTouches[0].clientY);
    const buttonElement = resolveButtonElement(element);
    if (ignoreTouchTarget && buttonElement === event.changedTouches[0].target) {
      return null;
    }
    return buttonElement;
  }
  return null;
};
var useDragRangeEvents = ({
  utils,
  setRangeDragDay,
  setIsDragging,
  isDragging,
  onDatePositionChange,
  onDrop,
  disableDragEditing,
  dateRange,
  timezone
}) => {
  const emptyDragImgRef = React8.useRef(null);
  React8.useEffect(() => {
    emptyDragImgRef.current = document.createElement("img");
    emptyDragImgRef.current.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
  }, []);
  const isElementDraggable = (day) => {
    if (day == null) {
      return false;
    }
    const shouldInitDragging = !disableDragEditing && !!dateRange[0] && !!dateRange[1];
    const isSelectedStartDate = isStartOfRange(utils, day, dateRange);
    const isSelectedEndDate = isEndOfRange(utils, day, dateRange);
    return shouldInitDragging && (isSelectedStartDate || isSelectedEndDate);
  };
  const handleDragStart = useEventCallback_default((event) => {
    const newDate = resolveDateFromTarget(event.target, utils, timezone);
    if (!isElementDraggable(newDate)) {
      return;
    }
    event.stopPropagation();
    if (emptyDragImgRef.current) {
      event.dataTransfer.setDragImage(emptyDragImgRef.current, 0, 0);
    }
    setRangeDragDay(newDate);
    event.dataTransfer.effectAllowed = "move";
    setIsDragging(true);
    const buttonDataset = event.target.dataset;
    if (buttonDataset.timestamp) {
      event.dataTransfer.setData("draggingDate", buttonDataset.timestamp);
    }
    if (buttonDataset.position) {
      onDatePositionChange(buttonDataset.position);
    }
  });
  const handleTouchStart = useEventCallback_default((event) => {
    const target = resolveElementFromTouch(event);
    if (!target) {
      return;
    }
    const newDate = resolveDateFromTarget(target, utils, timezone);
    if (!isElementDraggable(newDate)) {
      return;
    }
    setRangeDragDay(newDate);
  });
  const handleDragEnter = useEventCallback_default((event) => {
    if (!isDragging) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    event.dataTransfer.dropEffect = "move";
    setRangeDragDay(resolveDateFromTarget(event.target, utils, timezone));
  });
  const handleTouchMove = useEventCallback_default((event) => {
    const target = resolveElementFromTouch(event);
    if (!target) {
      return;
    }
    const newDate = resolveDateFromTarget(target, utils, timezone);
    if (newDate) {
      setRangeDragDay(newDate);
    }
    const targetsAreIdentical = target === event.changedTouches[0].target;
    if (!targetsAreIdentical || !isElementDraggable(newDate)) {
      return;
    }
    setIsDragging(true);
    const button = event.target;
    const buttonDataset = button.dataset;
    if (buttonDataset.position) {
      onDatePositionChange(buttonDataset.position);
    }
  });
  const handleDragLeave = useEventCallback_default((event) => {
    if (!isDragging) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
  });
  const handleDragOver = useEventCallback_default((event) => {
    if (!isDragging) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    event.dataTransfer.dropEffect = "move";
  });
  const handleTouchEnd = useEventCallback_default((event) => {
    if (!isDragging) {
      return;
    }
    setRangeDragDay(null);
    setIsDragging(false);
    const target = resolveElementFromTouch(event, true);
    if (!target) {
      return;
    }
    target.focus();
    const newDate = resolveDateFromTarget(target, utils, timezone);
    if (newDate) {
      onDrop(newDate);
    }
  });
  const handleDragEnd = useEventCallback_default((event) => {
    if (!isDragging) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    setIsDragging(false);
    setRangeDragDay(null);
  });
  const handleDrop = useEventCallback_default((event) => {
    if (!isDragging) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    setIsDragging(false);
    setRangeDragDay(null);
    event.currentTarget.focus();
    if (isSameAsDraggingDate(event)) {
      return;
    }
    const newDate = resolveDateFromTarget(event.target, utils, timezone);
    if (newDate) {
      onDrop(newDate);
    }
  });
  return {
    onDragStart: handleDragStart,
    onDragEnter: handleDragEnter,
    onDragLeave: handleDragLeave,
    onDragOver: handleDragOver,
    onDragEnd: handleDragEnd,
    onDrop: handleDrop,
    onTouchStart: handleTouchStart,
    onTouchMove: handleTouchMove,
    onTouchEnd: handleTouchEnd
  };
};
var useDragRange = ({
  disableDragEditing,
  utils,
  onDatePositionChange,
  onDrop,
  dateRange,
  timezone
}) => {
  const [isDragging, setIsDragging] = React8.useState(false);
  const [rangeDragDay, setRangeDragDay] = React8.useState(null);
  const handleRangeDragDayChange = useEventCallback_default((val) => {
    if (!utils.isEqual(val, rangeDragDay)) {
      setRangeDragDay(val);
    }
  });
  const draggingDatePosition = React8.useMemo(() => {
    const [start, end] = dateRange;
    if (rangeDragDay) {
      if (start && utils.isBefore(rangeDragDay, start)) {
        return "start";
      }
      if (end && utils.isAfter(rangeDragDay, end)) {
        return "end";
      }
    }
    return null;
  }, [dateRange, rangeDragDay, utils]);
  const dragRangeEvents = useDragRangeEvents({
    utils,
    onDatePositionChange,
    onDrop,
    setIsDragging,
    isDragging,
    setRangeDragDay: handleRangeDragDayChange,
    disableDragEditing,
    dateRange,
    timezone
  });
  return React8.useMemo(() => _extends({
    isDragging,
    rangeDragDay,
    draggingDatePosition
  }, !disableDragEditing ? dragRangeEvents : {}), [isDragging, rangeDragDay, draggingDatePosition, disableDragEditing, dragRangeEvents]);
};

// node_modules/@mui/x-date-pickers-pro/internals/hooks/useRangePosition.js
var React9 = __toESM(require_react());
init_useControlled();
init_useEventCallback();
var useRangePosition = (props) => {
  var _props$defaultRangePo;
  const singleInputFieldRef = React9.useRef();
  const [rangePosition, setRangePosition] = useControlled({
    name: "useRangePosition",
    state: "rangePosition",
    controlled: props.rangePosition,
    default: (_props$defaultRangePo = props.defaultRangePosition) != null ? _props$defaultRangePo : "start"
  });
  const syncRangePositionWithSingleInputField = (newRangePosition) => {
    if (singleInputFieldRef.current == null) {
      return;
    }
    const sections = singleInputFieldRef.current.getSections();
    const targetActiveSectionIndex = newRangePosition === "start" ? 0 : sections.length / 2;
    singleInputFieldRef.current.setSelectedSections(targetActiveSectionIndex);
  };
  const handleRangePositionChange = useEventCallback_default((newRangePosition) => {
    var _props$onRangePositio;
    setRangePosition(newRangePosition);
    (_props$onRangePositio = props.onRangePositionChange) == null || _props$onRangePositio.call(props, newRangePosition);
    syncRangePositionWithSingleInputField(newRangePosition);
  });
  return {
    rangePosition,
    onRangePositionChange: handleRangePositionChange,
    singleInputFieldRef
  };
};

// node_modules/@mui/x-date-pickers-pro/DateRangeCalendar/DateRangeCalendar.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var _excluded4 = ["value", "defaultValue", "referenceDate", "onChange", "className", "disableFuture", "disablePast", "minDate", "maxDate", "shouldDisableDate", "reduceAnimations", "onMonthChange", "defaultCalendarMonth", "rangePosition", "defaultRangePosition", "onRangePositionChange", "calendars", "currentMonthCalendarPosition", "components", "componentsProps", "slots", "slotProps", "loading", "renderLoading", "disableHighlightToday", "readOnly", "disabled", "showDaysOutsideCurrentMonth", "dayOfWeekFormatter", "disableAutoMonthSwitching", "autoFocus", "fixedWeekNumber", "disableDragEditing", "displayWeekNumber", "timezone"];
var _excluded22 = ["isDragging", "rangeDragDay", "draggingDatePosition"];
var releaseInfo2 = getReleaseInfo();
var DateRangeCalendarRoot = styled_default("div", {
  name: "MuiDateRangeCalendar",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})({
  display: "flex",
  flexDirection: "row"
});
var DateRangeCalendarMonthContainer = styled_default("div", {
  name: "MuiDateRangeCalendar",
  slot: "Container",
  overridesResolver: (_, styles) => styles.monthContainer
})(({
  theme
}) => ({
  "&:not(:last-of-type)": {
    borderRight: `1px solid ${(theme.vars || theme).palette.divider}`
  }
}));
var DateRangeCalendarArrowSwitcher = styled_default(PickersArrowSwitcher)({
  padding: "16px 16px 8px 16px",
  display: "flex",
  alignItems: "center",
  justifyContent: "space-between"
});
var DAY_RANGE_SIZE = 40;
var weeksContainerHeight = (DAY_RANGE_SIZE + DAY_MARGIN * 2) * 6;
var warnInvalidCurrentMonthCalendarPosition = buildWarning(["The `currentMonthCalendarPosition` prop must be an integer between `1` and the amount of calendars rendered.", "For example if you have 2 calendars rendered, it should be equal to either 1 or 2."]);
var DayCalendarForRange = styled_default(DayCalendar)(({
  theme
}) => ({
  minWidth: 312,
  minHeight: weeksContainerHeight,
  [`&.${dateRangeCalendarClasses.dayDragging}`]: {
    [`& .${dateRangePickerDayClasses.day}`]: {
      cursor: "grabbing"
    },
    [`& .${dateRangePickerDayClasses.root}:not(.${dateRangePickerDayClasses.rangeIntervalDayHighlightStart}):not(.${dateRangePickerDayClasses.rangeIntervalDayHighlightEnd}) .${dateRangePickerDayClasses.day}:not(.${dateRangePickerDayClasses.notSelectedDate})`]: {
      // we can't override `PickersDay` background color here, because it's styles take precedence
      opacity: 0.6
    }
  },
  [`&:not(.${dateRangeCalendarClasses.dayDragging}) .${dateRangePickerDayClasses.dayOutsideRangeInterval}`]: {
    "@media (pointer: fine)": {
      "&:hover": {
        border: `1px solid ${(theme.vars || theme).palette.grey[500]}`
      }
    }
  }
}));
function useDateRangeCalendarDefaultizedProps(props, name) {
  var _themeProps$renderLoa, _themeProps$reduceAni, _props$loading, _props$disablePast, _props$disableFuture, _themeProps$calendars, _themeProps$disableDr;
  const utils = useUtils();
  const defaultDates = useDefaultDates();
  const defaultReduceAnimations = useDefaultReduceAnimations();
  const themeProps = useThemeProps({
    props,
    name
  });
  return _extends({}, themeProps, {
    renderLoading: (_themeProps$renderLoa = themeProps.renderLoading) != null ? _themeProps$renderLoa : () => (0, import_jsx_runtime6.jsx)("span", {
      children: "..."
    }),
    reduceAnimations: (_themeProps$reduceAni = themeProps.reduceAnimations) != null ? _themeProps$reduceAni : defaultReduceAnimations,
    loading: (_props$loading = props.loading) != null ? _props$loading : false,
    disablePast: (_props$disablePast = props.disablePast) != null ? _props$disablePast : false,
    disableFuture: (_props$disableFuture = props.disableFuture) != null ? _props$disableFuture : false,
    minDate: applyDefaultDate(utils, themeProps.minDate, defaultDates.minDate),
    maxDate: applyDefaultDate(utils, themeProps.maxDate, defaultDates.maxDate),
    calendars: (_themeProps$calendars = themeProps.calendars) != null ? _themeProps$calendars : 2,
    disableDragEditing: (_themeProps$disableDr = themeProps.disableDragEditing) != null ? _themeProps$disableDr : false
  });
}
var useUtilityClasses3 = (ownerState) => {
  const {
    classes,
    isDragging
  } = ownerState;
  const slots = {
    root: ["root"],
    monthContainer: ["monthContainer"],
    dayCalendar: [isDragging && "dayDragging"]
  };
  return composeClasses(slots, getDateRangeCalendarUtilityClass, classes);
};
var DateRangeCalendar = React10.forwardRef(function DateRangeCalendar2(inProps, ref) {
  const props = useDateRangeCalendarDefaultizedProps(inProps, "MuiDateRangeCalendar");
  const shouldHavePreview = useMediaQuery(DEFAULT_DESKTOP_MODE_MEDIA_QUERY, {
    defaultMatches: false
  });
  const {
    value: valueProp,
    defaultValue,
    referenceDate,
    onChange,
    className,
    disableFuture,
    disablePast,
    minDate,
    maxDate,
    shouldDisableDate,
    reduceAnimations,
    onMonthChange,
    defaultCalendarMonth,
    rangePosition: rangePositionProp,
    defaultRangePosition: inDefaultRangePosition,
    onRangePositionChange: inOnRangePositionChange,
    calendars,
    currentMonthCalendarPosition = 1,
    components,
    componentsProps,
    slots: innerSlots,
    slotProps: innerSlotProps,
    loading,
    renderLoading,
    disableHighlightToday,
    readOnly,
    disabled,
    showDaysOutsideCurrentMonth,
    dayOfWeekFormatter,
    disableAutoMonthSwitching,
    autoFocus,
    fixedWeekNumber,
    disableDragEditing,
    displayWeekNumber,
    timezone: timezoneProp
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded4);
  const {
    value,
    handleValueChange,
    timezone
  } = useControlledValueWithTimezone({
    name: "DateRangeCalendar",
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    onChange,
    valueManager: rangeValueManager
  });
  const utils = useUtils();
  const localeText = useLocaleText();
  const now = useNow(timezone);
  const slots = innerSlots != null ? innerSlots : uncapitalizeObjectKeys(components);
  const slotProps = innerSlotProps != null ? innerSlotProps : componentsProps;
  const {
    rangePosition,
    onRangePositionChange
  } = useRangePosition({
    rangePosition: rangePositionProp,
    defaultRangePosition: inDefaultRangePosition,
    onRangePositionChange: inOnRangePositionChange
  });
  const handleDatePositionChange = useEventCallback_default((position) => {
    if (rangePosition !== position) {
      onRangePositionChange(position);
    }
  });
  const handleSelectedDayChange = useEventCallback_default((newDate, selectionState, allowRangeFlip = false) => {
    const {
      nextSelection,
      newRange
    } = calculateRangeChange({
      newDate,
      utils,
      range: value,
      rangePosition,
      allowRangeFlip
    });
    onRangePositionChange(nextSelection);
    const isFullRangeSelected = rangePosition === "end" && isRangeValid(utils, newRange);
    handleValueChange(newRange, isFullRangeSelected ? "finish" : "partial");
  });
  const handleDrop = useEventCallback_default((newDate) => {
    handleSelectedDayChange(newDate, void 0, true);
  });
  const shouldDisableDragEditing = disableDragEditing || disabled || readOnly;
  const valueDayRange = React10.useMemo(() => [value[0] == null || !utils.isValid(value[0]) ? value[0] : utils.startOfDay(value[0]), value[1] == null || !utils.isValid(value[1]) ? value[1] : utils.endOfDay(value[1])], [value, utils]);
  const _useDragRange = useDragRange({
    disableDragEditing: shouldDisableDragEditing,
    onDrop: handleDrop,
    onDatePositionChange: handleDatePositionChange,
    utils,
    dateRange: valueDayRange,
    timezone
  }), {
    isDragging,
    rangeDragDay,
    draggingDatePosition
  } = _useDragRange, dragEventHandlers = _objectWithoutPropertiesLoose(_useDragRange, _excluded22);
  const ownerState = _extends({}, props, {
    isDragging
  });
  const classes = useUtilityClasses3(ownerState);
  const draggingRange = React10.useMemo(() => {
    if (!valueDayRange[0] || !valueDayRange[1] || !rangeDragDay) {
      return [null, null];
    }
    const newRange = calculateRangeChange({
      utils,
      range: valueDayRange,
      newDate: rangeDragDay,
      rangePosition,
      allowRangeFlip: true
    }).newRange;
    return newRange[0] !== null && newRange[1] !== null ? [utils.startOfDay(newRange[0]), utils.endOfDay(newRange[1])] : newRange;
  }, [rangePosition, rangeDragDay, utils, valueDayRange]);
  const wrappedShouldDisableDate = React10.useMemo(() => {
    if (!shouldDisableDate) {
      return void 0;
    }
    return (dayToTest) => shouldDisableDate(dayToTest, draggingDatePosition || rangePosition);
  }, [shouldDisableDate, rangePosition, draggingDatePosition]);
  const {
    calendarState,
    changeFocusedDay,
    changeMonth,
    handleChangeMonth,
    onMonthSwitchingAnimationEnd
  } = useCalendarState({
    value: value[0] || value[1],
    referenceDate,
    defaultCalendarMonth,
    disableFuture,
    disablePast,
    disableSwitchToMonthOnDayFocus: true,
    maxDate,
    minDate,
    onMonthChange,
    reduceAnimations,
    shouldDisableDate: wrappedShouldDisableDate,
    timezone
  });
  const prevValue = React10.useRef(null);
  React10.useEffect(() => {
    var _prevValue$current, _prevValue$current2;
    const date = rangePosition === "start" ? value[0] : value[1];
    if (!date || !utils.isValid(date)) {
      return;
    }
    const prevDate = rangePosition === "start" ? (_prevValue$current = prevValue.current) == null ? void 0 : _prevValue$current[0] : (_prevValue$current2 = prevValue.current) == null ? void 0 : _prevValue$current2[1];
    prevValue.current = value;
    if (disableAutoMonthSwitching && prevDate && utils.isEqual(prevDate, date)) {
      return;
    }
    const displayingMonthRange = calendars - 1;
    const currentMonthNumber = utils.getMonth(calendarState.currentMonth);
    const requestedMonthNumber = utils.getMonth(date);
    if (!utils.isSameYear(calendarState.currentMonth, date) || requestedMonthNumber < currentMonthNumber || requestedMonthNumber > currentMonthNumber + displayingMonthRange) {
      const newMonth = rangePosition === "start" ? date : (
        // If need to focus end, scroll to the state when "end" is displaying in the last calendar
        utils.addMonths(date, -displayingMonthRange)
      );
      changeMonth(newMonth);
    }
  }, [rangePosition, value]);
  const selectNextMonth = React10.useCallback(() => {
    changeMonth(utils.addMonths(calendarState.currentMonth, 1));
  }, [changeMonth, calendarState.currentMonth, utils]);
  const selectPreviousMonth = React10.useCallback(() => {
    changeMonth(utils.addMonths(calendarState.currentMonth, -1));
  }, [changeMonth, calendarState.currentMonth, utils]);
  const isNextMonthDisabled = useNextMonthDisabled(calendarState.currentMonth, {
    disableFuture,
    maxDate,
    timezone
  });
  const isPreviousMonthDisabled = usePreviousMonthDisabled(calendarState.currentMonth, {
    disablePast,
    minDate,
    timezone
  });
  const baseDateValidationProps = {
    disablePast,
    disableFuture,
    maxDate,
    minDate
  };
  const commonViewProps = {
    disableHighlightToday,
    readOnly,
    disabled
  };
  const minDateWithDisabled = disabled && value[0] || minDate;
  const maxDateWithDisabled = disabled && value[1] || maxDate;
  const [rangePreviewDay, setRangePreviewDay] = React10.useState(null);
  const CalendarTransitionProps = React10.useMemo(() => ({
    onMouseLeave: () => setRangePreviewDay(null)
  }), []);
  const previewingRange = calculateRangePreview({
    utils,
    range: valueDayRange,
    newDate: rangePreviewDay,
    rangePosition
  });
  const handleDayMouseEnter = useEventCallback_default((event, newPreviewRequest) => {
    if (!isWithinRange(utils, newPreviewRequest, valueDayRange)) {
      setRangePreviewDay(newPreviewRequest);
    } else {
      setRangePreviewDay(null);
    }
  });
  const slotsForDayCalendar = _extends({
    day: DateRangePickerDay2
  }, slots);
  const slotPropsForDayCalendar = _extends({}, slotProps, {
    day: (dayOwnerState) => {
      var _resolveComponentProp;
      const {
        day
      } = dayOwnerState;
      const isSelectedStartDate = isStartOfRange(utils, day, valueDayRange);
      const isSelectedEndDate = isEndOfRange(utils, day, valueDayRange);
      const shouldInitDragging = !shouldDisableDragEditing && valueDayRange[0] && valueDayRange[1];
      const isElementDraggable = shouldInitDragging && (isSelectedStartDate || isSelectedEndDate);
      let datePosition;
      if (isSelectedStartDate) {
        datePosition = "start";
      } else if (isSelectedEndDate) {
        datePosition = "end";
      }
      const isStartOfHighlighting = isDragging ? isStartOfRange(utils, day, draggingRange) : isSelectedStartDate;
      const isEndOfHighlighting = isDragging ? isEndOfRange(utils, day, draggingRange) : isSelectedEndDate;
      return _extends({
        isPreviewing: shouldHavePreview ? isWithinRange(utils, day, previewingRange) : false,
        isStartOfPreviewing: shouldHavePreview ? isStartOfRange(utils, day, previewingRange) : false,
        isEndOfPreviewing: shouldHavePreview ? isEndOfRange(utils, day, previewingRange) : false,
        isHighlighting: isWithinRange(utils, day, isDragging ? draggingRange : valueDayRange),
        isStartOfHighlighting,
        isEndOfHighlighting: isDragging ? isEndOfRange(utils, day, draggingRange) : isSelectedEndDate,
        onMouseEnter: shouldHavePreview ? handleDayMouseEnter : void 0,
        // apply selected styling to the dragging start or end day
        isVisuallySelected: dayOwnerState.selected || isDragging && (isStartOfHighlighting || isEndOfHighlighting),
        "data-position": datePosition
      }, dragEventHandlers, {
        draggable: isElementDraggable ? true : void 0
      }, (_resolveComponentProp = resolveComponentProps(slotProps == null ? void 0 : slotProps.day, dayOwnerState)) != null ? _resolveComponentProp : {});
    }
  });
  const calendarMonths = React10.useMemo(() => Array.from({
    length: calendars
  }).map((_, index) => index), [calendars]);
  const visibleMonths = React10.useMemo(() => {
    if (true) {
      if (currentMonthCalendarPosition > calendars || currentMonthCalendarPosition < 1) {
        warnInvalidCurrentMonthCalendarPosition();
      }
    }
    const firstMonth = utils.addMonths(calendarState.currentMonth, 1 - currentMonthCalendarPosition);
    return Array.from({
      length: calendars
    }).map((_, index) => utils.addMonths(firstMonth, index));
  }, [utils, calendarState.currentMonth, calendars, currentMonthCalendarPosition]);
  const focusedMonth = React10.useMemo(() => {
    var _visibleMonths$find;
    if (!autoFocus) {
      return null;
    }
    if (value[0] != null) {
      return visibleMonths.find((month) => utils.isSameMonth(month, value[0]));
    }
    if (value[1] != null) {
      return visibleMonths.find((month) => utils.isSameMonth(month, value[1]));
    }
    return (_visibleMonths$find = visibleMonths.find((month) => utils.isSameMonth(month, now))) != null ? _visibleMonths$find : visibleMonths[0];
  }, [utils, value, visibleMonths, autoFocus, now]);
  return (0, import_jsx_runtime7.jsxs)(DateRangeCalendarRoot, _extends({
    ref,
    className: clsx_default(className, classes.root),
    ownerState
  }, other, {
    children: [(0, import_jsx_runtime6.jsx)(Watermark, {
      packageName: "x-date-pickers-pro",
      releaseInfo: releaseInfo2
    }), calendarMonths.map((month, index) => (0, import_jsx_runtime7.jsxs)(DateRangeCalendarMonthContainer, {
      className: classes.monthContainer,
      children: [calendars === 1 ? (0, import_jsx_runtime6.jsx)(PickersCalendarHeader, {
        views: ["day"],
        view: "day",
        currentMonth: calendarState.currentMonth,
        onMonthChange: (newMonth, direction) => handleChangeMonth({
          newMonth,
          direction
        }),
        minDate: minDateWithDisabled,
        maxDate: maxDateWithDisabled,
        disabled,
        disablePast,
        disableFuture,
        reduceAnimations,
        slots,
        slotProps,
        timezone
      }) : (0, import_jsx_runtime6.jsx)(DateRangeCalendarArrowSwitcher, {
        onGoToPrevious: selectPreviousMonth,
        onGoToNext: selectNextMonth,
        isPreviousHidden: index !== 0,
        isPreviousDisabled: isPreviousMonthDisabled,
        previousLabel: localeText.previousMonth,
        isNextHidden: index !== calendars - 1,
        isNextDisabled: isNextMonthDisabled,
        nextLabel: localeText.nextMonth,
        slots,
        slotProps,
        children: utils.format(visibleMonths[month], "monthAndYear")
      }), (0, import_jsx_runtime6.jsx)(DayCalendarForRange, _extends({
        className: classes.dayCalendar
      }, calendarState, baseDateValidationProps, commonViewProps, {
        onMonthSwitchingAnimationEnd,
        onFocusedDayChange: changeFocusedDay,
        reduceAnimations,
        selectedDays: value,
        onSelectedDaysChange: handleSelectedDayChange,
        currentMonth: visibleMonths[month],
        TransitionProps: CalendarTransitionProps,
        shouldDisableDate: wrappedShouldDisableDate,
        showDaysOutsideCurrentMonth: calendars === 1 && showDaysOutsideCurrentMonth,
        dayOfWeekFormatter,
        loading,
        renderLoading,
        slots: slotsForDayCalendar,
        slotProps: slotPropsForDayCalendar,
        autoFocus: visibleMonths[month] === focusedMonth,
        fixedWeekNumber,
        displayWeekNumber,
        timezone
      }), index)]
    }, month))]
  }));
});
true ? DateRangeCalendar.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: import_prop_types3.default.bool,
  /**
   * The number of calendars to render.
   * @default 2
   */
  calendars: import_prop_types3.default.oneOf([1, 2, 3]),
  classes: import_prop_types3.default.object,
  className: import_prop_types3.default.string,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: import_prop_types3.default.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: import_prop_types3.default.object,
  /**
   * Position the current month is rendered in.
   * @default 1
   */
  currentMonthCalendarPosition: import_prop_types3.default.oneOf([1, 2, 3]),
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {string} day The day of week provided by the adapter.  Deprecated, will be removed in v7: Use `date` instead.
   * @param {TDate} date The date of the day of week provided by the adapter.
   * @returns {string} The name to display.
   * @default (_day: string, date: TDate) => adapter.format(date, 'weekdayShort').charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: import_prop_types3.default.func,
  /**
   * Default calendar month displayed when `value={[null, null]}`.
   * @deprecated Consider using `referenceDate` instead.
   */
  defaultCalendarMonth: import_prop_types3.default.any,
  /**
   * The initial position in the edited date range.
   * Used when the component is not controlled.
   * @default 'start'
   */
  defaultRangePosition: import_prop_types3.default.oneOf(["end", "start"]),
  /**
   * The default selected value.
   * Used when the component is not controlled.
   */
  defaultValue: import_prop_types3.default.arrayOf(import_prop_types3.default.any),
  /**
   * If `true`, after selecting `start` date calendar will not automatically switch to the month of `end` date.
   * @default false
   */
  disableAutoMonthSwitching: import_prop_types3.default.bool,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: import_prop_types3.default.bool,
  /**
   * If `true`, editing dates by dragging is disabled.
   * @default false
   */
  disableDragEditing: import_prop_types3.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types3.default.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: import_prop_types3.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types3.default.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: import_prop_types3.default.bool,
  /**
   * Calendar will show more weeks in order to match this value.
   * Put it to 6 for having fix number of week in Gregorian calendars
   * @default undefined
   */
  fixedWeekNumber: import_prop_types3.default.number,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: import_prop_types3.default.bool,
  /**
   * Maximal selectable date.
   */
  maxDate: import_prop_types3.default.any,
  /**
   * Minimal selectable date.
   */
  minDate: import_prop_types3.default.any,
  /**
   * Callback fired when the value changes.
   * @template TDate
   * @param {DateRange<TDate>} value The new value.
   * @param {PickerSelectionState | undefined} selectionState Indicates if the date range selection is complete.
   */
  onChange: import_prop_types3.default.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: import_prop_types3.default.func,
  /**
   * Callback fired when the range position changes.
   * @param {RangePosition} rangePosition The new range position.
   */
  onRangePositionChange: import_prop_types3.default.func,
  /**
   * The position in the currently edited date range.
   * Used when the component position is controlled.
   */
  rangePosition: import_prop_types3.default.oneOf(["end", "start"]),
  /**
   * Make picker read only.
   * @default false
   */
  readOnly: import_prop_types3.default.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: import_prop_types3.default.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date using the validation props, except callbacks such as `shouldDisableDate`.
   */
  referenceDate: import_prop_types3.default.any,
  /**
   * Component displaying when passed `loading` true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => "..."
   */
  renderLoading: import_prop_types3.default.func,
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (e.g. when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @param {string} position The date to test, 'start' or 'end'.
   * @returns {boolean} Returns `true` if the date should be disabled.
   */
  shouldDisableDate: import_prop_types3.default.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: import_prop_types3.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types3.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types3.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types3.default.oneOfType([import_prop_types3.default.arrayOf(import_prop_types3.default.oneOfType([import_prop_types3.default.func, import_prop_types3.default.object, import_prop_types3.default.bool])), import_prop_types3.default.func, import_prop_types3.default.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documention} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types3.default.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types3.default.arrayOf(import_prop_types3.default.any)
} : void 0;

// node_modules/@mui/x-date-pickers-pro/dateRangeViewRenderers/dateRangeViewRenderers.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
var renderDateRangeViewCalendar = ({
  value,
  defaultValue,
  referenceDate,
  onChange,
  className,
  classes,
  disableFuture,
  disablePast,
  minDate,
  maxDate,
  shouldDisableDate,
  reduceAnimations,
  onMonthChange,
  defaultCalendarMonth,
  rangePosition,
  defaultRangePosition,
  onRangePositionChange,
  calendars,
  currentMonthCalendarPosition,
  components,
  componentsProps,
  slots,
  slotProps,
  loading,
  renderLoading,
  disableHighlightToday,
  readOnly,
  disabled,
  showDaysOutsideCurrentMonth,
  dayOfWeekFormatter,
  disableAutoMonthSwitching,
  sx,
  autoFocus,
  fixedWeekNumber,
  disableDragEditing,
  displayWeekNumber,
  timezone
}) => (0, import_jsx_runtime8.jsx)(DateRangeCalendar, {
  value,
  defaultValue,
  referenceDate,
  onChange,
  className,
  classes,
  disableFuture,
  disablePast,
  minDate,
  maxDate,
  shouldDisableDate,
  reduceAnimations,
  onMonthChange,
  defaultCalendarMonth,
  rangePosition,
  defaultRangePosition,
  onRangePositionChange,
  calendars,
  currentMonthCalendarPosition,
  components,
  componentsProps,
  slots,
  slotProps,
  loading,
  renderLoading,
  disableHighlightToday,
  readOnly,
  disabled,
  showDaysOutsideCurrentMonth,
  dayOfWeekFormatter,
  disableAutoMonthSwitching,
  sx,
  autoFocus,
  fixedWeekNumber,
  disableDragEditing,
  displayWeekNumber,
  timezone
});

// node_modules/@mui/x-date-pickers-pro/MultiInputDateRangeField/MultiInputDateRangeField.js
init_objectWithoutPropertiesLoose();
init_extends();
var React12 = __toESM(require_react());
var import_prop_types4 = __toESM(require_prop_types());
init_clsx();
init_esm();

// node_modules/@mui/x-date-pickers-pro/internals/hooks/useMultiInputRangeField/useMultiInputDateRangeField.js
init_extends();
init_useEventCallback();

// node_modules/@mui/x-date-pickers-pro/internals/hooks/useMultiInputRangeField/shared.js
var excludeProps = (props, excludedProps) => {
  return Object.keys(props).reduce((acc, key) => {
    if (!excludedProps.includes(key)) {
      acc[key] = props[key];
    }
    return acc;
  }, {});
};

// node_modules/@mui/x-date-pickers-pro/internals/hooks/useMultiInputRangeField/useMultiInputDateRangeField.js
var useMultiInputDateRangeField = ({
  sharedProps: inSharedProps,
  startTextFieldProps,
  startInputRef,
  unstableStartFieldRef,
  endTextFieldProps,
  endInputRef,
  unstableEndFieldRef
}) => {
  const sharedProps = useDefaultizedDateRangeFieldProps(inSharedProps);
  const adapter = useLocalizationContext();
  const {
    value: valueProp,
    defaultValue,
    format,
    formatDensity,
    shouldRespectLeadingZeros,
    onChange,
    disabled,
    readOnly,
    selectedSections,
    onSelectedSectionsChange,
    timezone: timezoneProp
  } = sharedProps;
  const {
    value,
    handleValueChange,
    timezone
  } = useControlledValueWithTimezone({
    name: "useMultiInputDateRangeField",
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    onChange,
    valueManager: rangeValueManager
  });
  const buildChangeHandler = (index) => {
    return (newDate, rawContext) => {
      const newDateRange = index === 0 ? [newDate, value[1]] : [value[0], newDate];
      const context = _extends({}, rawContext, {
        validationError: validateDateRange({
          adapter,
          value: newDateRange,
          props: _extends({}, sharedProps, {
            timezone
          })
        })
      });
      handleValueChange(newDateRange, context);
    };
  };
  const handleStartDateChange = useEventCallback_default(buildChangeHandler(0));
  const handleEndDateChange = useEventCallback_default(buildChangeHandler(1));
  const validationError = useValidation(_extends({}, sharedProps, {
    value,
    timezone
  }), validateDateRange, rangeValueManager.isSameError, rangeValueManager.defaultErrorState);
  const startFieldProps = _extends({
    error: !!validationError[0]
  }, startTextFieldProps, {
    disabled,
    readOnly,
    format,
    formatDensity,
    shouldRespectLeadingZeros,
    timezone,
    unstableFieldRef: unstableStartFieldRef,
    value: valueProp === void 0 ? void 0 : valueProp[0],
    defaultValue: defaultValue === void 0 ? void 0 : defaultValue[0],
    onChange: handleStartDateChange,
    selectedSections,
    onSelectedSectionsChange
  });
  const endFieldProps = _extends({
    error: !!validationError[1]
  }, endTextFieldProps, {
    format,
    formatDensity,
    shouldRespectLeadingZeros,
    disabled,
    readOnly,
    timezone,
    unstableFieldRef: unstableEndFieldRef,
    value: valueProp === void 0 ? void 0 : valueProp[1],
    defaultValue: defaultValue === void 0 ? void 0 : defaultValue[1],
    onChange: handleEndDateChange,
    selectedSections,
    onSelectedSectionsChange
  });
  const startDateResponse = useDateField({
    props: startFieldProps,
    inputRef: startInputRef
  });
  const endDateResponse = useDateField({
    props: endFieldProps,
    inputRef: endInputRef
  });
  return {
    startDate: excludeProps(startDateResponse, ["clearable", "onClear"]),
    endDate: excludeProps(endDateResponse, ["clearable", "onClear"])
  };
};

// node_modules/@mui/x-date-pickers-pro/MultiInputDateRangeField/MultiInputDateRangeField.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
var _excluded5 = ["slots", "slotProps", "components", "componentsProps", "disabled", "autoFocus", "unstableStartFieldRef", "unstableEndFieldRef", "className"];
var _excluded23 = ["onKeyDown", "ref", "readOnly", "inputMode"];
var _excluded32 = ["onKeyDown", "ref", "readOnly", "inputMode"];
var multiInputDateRangeFieldClasses = generateUtilityClasses("MuiMultiInputDateRangeField", ["root", "separator"]);
var getMultiInputDateRangeFieldUtilityClass = (slot) => generateUtilityClass("MuiMultiInputDateRangeField", slot);
var useUtilityClasses4 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    separator: ["separator"]
  };
  return composeClasses(slots, getMultiInputDateRangeFieldUtilityClass, classes);
};
var MultiInputDateRangeFieldRoot = styled_default(React12.forwardRef((props, ref) => (0, import_jsx_runtime9.jsx)(Stack_default, _extends({
  ref,
  spacing: 2,
  direction: "row",
  alignItems: "baseline"
}, props))), {
  name: "MuiMultiInputDateRangeField",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})({});
var MultiInputDateRangeFieldSeparator = styled_default((props) => {
  var _props$children;
  return (0, import_jsx_runtime9.jsx)(Typography_default, _extends({}, props, {
    children: (_props$children = props.children) != null ? _props$children : " – "
  }));
}, {
  name: "MuiMultiInputDateRangeField",
  slot: "Separator",
  overridesResolver: (props, styles) => styles.separator
})({});
var MultiInputDateRangeField = React12.forwardRef(function MultiInputDateRangeField2(inProps, ref) {
  var _slots$root, _slots$textField, _slots$separator, _slotProps$separator;
  const themeProps = useThemeProps({
    props: inProps,
    name: "MuiMultiInputDateRangeField"
  });
  const {
    internalProps: dateFieldInternalProps,
    forwardedProps
  } = splitFieldInternalAndForwardedProps(themeProps, "date");
  const {
    slots: innerSlots,
    slotProps: innerSlotProps,
    components,
    componentsProps,
    disabled,
    autoFocus,
    unstableStartFieldRef,
    unstableEndFieldRef,
    className
  } = forwardedProps, otherForwardedProps = _objectWithoutPropertiesLoose(forwardedProps, _excluded5);
  const slots = innerSlots != null ? innerSlots : uncapitalizeObjectKeys(components);
  const slotProps = innerSlotProps != null ? innerSlotProps : componentsProps;
  const ownerState = themeProps;
  const classes = useUtilityClasses4(ownerState);
  const Root = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : MultiInputDateRangeFieldRoot;
  const rootProps = useSlotProps({
    elementType: Root,
    externalSlotProps: slotProps == null ? void 0 : slotProps.root,
    externalForwardedProps: otherForwardedProps,
    additionalProps: {
      ref
    },
    ownerState,
    className: clsx_default(className, classes.root)
  });
  const TextField = (_slots$textField = slots == null ? void 0 : slots.textField) != null ? _slots$textField : TextField_default;
  const startTextFieldProps = useSlotProps({
    elementType: TextField,
    externalSlotProps: slotProps == null ? void 0 : slotProps.textField,
    additionalProps: {
      autoFocus
    },
    ownerState: _extends({}, ownerState, {
      position: "start"
    })
  });
  const endTextFieldProps = useSlotProps({
    elementType: TextField,
    externalSlotProps: slotProps == null ? void 0 : slotProps.textField,
    ownerState: _extends({}, ownerState, {
      position: "end"
    })
  });
  const Separator = (_slots$separator = slots == null ? void 0 : slots.separator) != null ? _slots$separator : MultiInputDateRangeFieldSeparator;
  const separatorProps = useSlotProps({
    elementType: Separator,
    externalSlotProps: (_slotProps$separator = slotProps == null ? void 0 : slotProps.separator) != null ? _slotProps$separator : componentsProps == null ? void 0 : componentsProps.separator,
    ownerState,
    className: classes.separator
  });
  const _useMultiInputDateRan = useMultiInputDateRangeField({
    sharedProps: _extends({}, dateFieldInternalProps, {
      disabled
    }),
    startTextFieldProps,
    endTextFieldProps,
    unstableStartFieldRef,
    unstableEndFieldRef,
    startInputRef: startTextFieldProps.inputRef,
    endInputRef: endTextFieldProps.inputRef
  }), {
    startDate: {
      onKeyDown: onStartInputKeyDown,
      ref: startInputRef,
      readOnly: startReadOnly,
      inputMode: startInputMode
    },
    endDate: {
      onKeyDown: onEndInputKeyDown,
      ref: endInputRef,
      readOnly: endReadOnly,
      inputMode: endInputMode
    }
  } = _useMultiInputDateRan, startDateProps = _objectWithoutPropertiesLoose(_useMultiInputDateRan.startDate, _excluded32), endDateProps = _objectWithoutPropertiesLoose(_useMultiInputDateRan.endDate, _excluded23);
  return (0, import_jsx_runtime10.jsxs)(Root, _extends({}, rootProps, {
    children: [(0, import_jsx_runtime9.jsx)(TextField, _extends({
      fullWidth: true
    }, startDateProps, {
      InputProps: _extends({}, startDateProps.InputProps, {
        readOnly: startReadOnly
      }),
      inputProps: _extends({}, startDateProps.inputProps, {
        ref: startInputRef,
        inputMode: startInputMode,
        onKeyDown: onStartInputKeyDown
      })
    })), (0, import_jsx_runtime9.jsx)(Separator, _extends({}, separatorProps)), (0, import_jsx_runtime9.jsx)(TextField, _extends({
      fullWidth: true
    }, endDateProps, {
      InputProps: _extends({}, endDateProps.InputProps, {
        readOnly: endReadOnly
      }),
      inputProps: _extends({}, endDateProps.inputProps, {
        ref: endInputRef,
        readOnly: endReadOnly,
        inputMode: endInputMode,
        onKeyDown: onEndInputKeyDown
      })
    }))]
  }));
});
true ? MultiInputDateRangeField.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  autoFocus: import_prop_types4.default.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types4.default.object,
  className: import_prop_types4.default.string,
  component: import_prop_types4.default.elementType,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: import_prop_types4.default.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: import_prop_types4.default.object,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: import_prop_types4.default.arrayOf(import_prop_types4.default.any),
  /**
   * Defines the `flex-direction` style property.
   * It is applied for all screen sizes.
   * @default 'column'
   */
  direction: import_prop_types4.default.oneOfType([import_prop_types4.default.oneOf(["column-reverse", "column", "row-reverse", "row"]), import_prop_types4.default.arrayOf(import_prop_types4.default.oneOf(["column-reverse", "column", "row-reverse", "row"])), import_prop_types4.default.object]),
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: import_prop_types4.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types4.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types4.default.bool,
  /**
   * Add an element between each child.
   */
  divider: import_prop_types4.default.node,
  /**
   * Format of the date when rendered in the input(s).
   */
  format: import_prop_types4.default.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: import_prop_types4.default.oneOf(["dense", "spacious"]),
  /**
   * Maximal selectable date.
   */
  maxDate: import_prop_types4.default.any,
  /**
   * Minimal selectable date.
   */
  minDate: import_prop_types4.default.any,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: import_prop_types4.default.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error.
   * @param {TValue} value The value associated to the error.
   */
  onError: import_prop_types4.default.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: import_prop_types4.default.func,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   * @default false
   */
  readOnly: import_prop_types4.default.bool,
  /**
   * The date used to generate a part of the new value that is not present in the format when both `value` and `defaultValue` are empty.
   * For example, on time fields it will be used to determine the date to set.
   * @default The closest valid date using the validation props, except callbacks such as `shouldDisableDate`. Value is rounded to the most granular section used.
   */
  referenceDate: import_prop_types4.default.any,
  /**
   * The currently selected sections.
   * This prop accept four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
   * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 4. If `null` is provided, no section will be selected
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: import_prop_types4.default.oneOfType([import_prop_types4.default.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), import_prop_types4.default.number, import_prop_types4.default.shape({
    endIndex: import_prop_types4.default.number.isRequired,
    startIndex: import_prop_types4.default.number.isRequired
  })]),
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (e.g. when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @param {string} position The date to test, 'start' or 'end'.
   * @returns {boolean} Returns `true` if the date should be disabled.
   */
  shouldDisableDate: import_prop_types4.default.func,
  /**
   * If `true`, the format will respect the leading zeroes (e.g: on dayjs, the format `M/D/YYYY` will render `8/16/2018`)
   * If `false`, the format will always add leading zeroes (e.g: on dayjs, the format `M/D/YYYY` will render `08/16/2018`)
   *
   * Warning n°1: Luxon is not able to respect the leading zeroes when using macro tokens (e.g: "DD"), so `shouldRespectLeadingZeros={true}` might lead to inconsistencies when using `AdapterLuxon`.
   *
   * Warning n°2: When `shouldRespectLeadingZeros={true}`, the field will add an invisible character on the sections containing a single digit to make sure `onChange` is fired.
   * If you need to get the clean value from the input, you can remove this character using `input.value.replace(/\u200e/g, '')`.
   *
   * Warning n°3: When used in strict mode, dayjs and moment require to respect the leading zeros.
   * This mean that when using `shouldRespectLeadingZeros={false}`, if you retrieve the value directly from the input (not listening to `onChange`) and your format contains tokens without leading zeros, the value will not be parsed by your library.
   *
   * @default `false`
   */
  shouldRespectLeadingZeros: import_prop_types4.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types4.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types4.default.object,
  /**
   * Defines the space between immediate children.
   * @default 0
   */
  spacing: import_prop_types4.default.oneOfType([import_prop_types4.default.arrayOf(import_prop_types4.default.oneOfType([import_prop_types4.default.number, import_prop_types4.default.string])), import_prop_types4.default.number, import_prop_types4.default.object, import_prop_types4.default.string]),
  style: import_prop_types4.default.object,
  /**
   * The system prop, which allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types4.default.oneOfType([import_prop_types4.default.arrayOf(import_prop_types4.default.oneOfType([import_prop_types4.default.func, import_prop_types4.default.object, import_prop_types4.default.bool])), import_prop_types4.default.func, import_prop_types4.default.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documention} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types4.default.string,
  unstableEndFieldRef: import_prop_types4.default.oneOfType([import_prop_types4.default.func, import_prop_types4.default.object]),
  unstableStartFieldRef: import_prop_types4.default.oneOfType([import_prop_types4.default.func, import_prop_types4.default.object]),
  /**
   * If `true`, the CSS flexbox `gap` is used instead of applying `margin` to children.
   *
   * While CSS `gap` removes the [known limitations](https://mui.com/joy-ui/react-stack/#limitations),
   * it is not fully supported in some browsers. We recommend checking https://caniuse.com/?search=flex%20gap before using this flag.
   *
   * To enable this flag globally, follow the [theme's default props](https://mui.com/material-ui/customization/theme-components/#default-props) configuration.
   * @default false
   */
  useFlexGap: import_prop_types4.default.bool,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types4.default.arrayOf(import_prop_types4.default.any)
} : void 0;

// node_modules/@mui/x-date-pickers-pro/internals/hooks/useDesktopRangePicker/useDesktopRangePicker.js
init_extends();
init_objectWithoutPropertiesLoose();
var React14 = __toESM(require_react());

// node_modules/@mui/x-date-pickers-pro/internals/hooks/useEnrichedRangePickerFieldProps.js
init_objectWithoutPropertiesLoose();
init_extends();
var React13 = __toESM(require_react());
init_useEventCallback();
init_useForkRef();
var _excluded6 = ["clearable", "onClear"];
var useMultiInputFieldSlotProps = ({
  wrapperVariant,
  open,
  actions,
  readOnly,
  labelId,
  disableOpenPicker,
  onBlur,
  rangePosition,
  onRangePositionChange,
  localeText: inLocaleText,
  pickerSlotProps,
  pickerSlots,
  fieldProps,
  anchorRef
}) => {
  const localeText = useLocaleText();
  const startRef = React13.useRef(null);
  const endRef = React13.useRef(null);
  React13.useEffect(() => {
    if (!open) {
      return;
    }
    if (rangePosition === "start") {
      var _startRef$current;
      (_startRef$current = startRef.current) == null || _startRef$current.focus();
    } else if (rangePosition === "end") {
      var _endRef$current;
      (_endRef$current = endRef.current) == null || _endRef$current.focus();
    }
  }, [rangePosition, open]);
  const openRangeStartSelection = (event) => {
    event.stopPropagation();
    onRangePositionChange("start");
    if (!readOnly && !disableOpenPicker) {
      actions.onOpen();
    }
  };
  const openRangeEndSelection = (event) => {
    event.stopPropagation();
    onRangePositionChange("end");
    if (!readOnly && !disableOpenPicker) {
      actions.onOpen();
    }
  };
  const handleFocusStart = () => {
    if (open) {
      onRangePositionChange("start");
    }
  };
  const handleFocusEnd = () => {
    if (open) {
      onRangePositionChange("end");
    }
  };
  const slots = _extends({
    textField: pickerSlots == null ? void 0 : pickerSlots.textField,
    root: pickerSlots == null ? void 0 : pickerSlots.fieldRoot,
    separator: pickerSlots == null ? void 0 : pickerSlots.fieldSeparator
  }, fieldProps.slots);
  const slotProps = _extends({}, fieldProps.slotProps, {
    textField: (ownerState) => {
      const resolvedComponentProps = resolveComponentProps(pickerSlotProps == null ? void 0 : pickerSlotProps.textField, ownerState);
      let inputProps;
      let InputProps;
      if (ownerState.position === "start") {
        var _inLocaleText$start;
        inputProps = _extends({
          inputRef: startRef,
          label: (_inLocaleText$start = inLocaleText == null ? void 0 : inLocaleText.start) != null ? _inLocaleText$start : localeText.start,
          onKeyDown: onSpaceOrEnter(openRangeStartSelection),
          onFocus: handleFocusStart,
          focused: open ? rangePosition === "start" : void 0
        }, !readOnly && !fieldProps.disabled && {
          onClick: openRangeStartSelection
        }, wrapperVariant === "mobile" && {
          readOnly: true
        });
        if (anchorRef) {
          InputProps = _extends({}, resolvedComponentProps == null ? void 0 : resolvedComponentProps.InputProps, {
            ref: anchorRef
          });
        }
      } else {
        var _inLocaleText$end;
        inputProps = _extends({
          inputRef: endRef,
          label: (_inLocaleText$end = inLocaleText == null ? void 0 : inLocaleText.end) != null ? _inLocaleText$end : localeText.end,
          onKeyDown: onSpaceOrEnter(openRangeEndSelection),
          onFocus: handleFocusEnd,
          focused: open ? rangePosition === "end" : void 0
        }, !readOnly && !fieldProps.disabled && {
          onClick: openRangeEndSelection
        }, wrapperVariant === "mobile" && {
          readOnly: true
        });
        InputProps = resolvedComponentProps == null ? void 0 : resolvedComponentProps.InputProps;
      }
      return _extends({}, labelId != null && {
        id: `${labelId}-${ownerState.position}`
      }, inputProps, resolveComponentProps(pickerSlotProps == null ? void 0 : pickerSlotProps.textField, ownerState), {
        InputProps
      });
    },
    root: (ownerState) => {
      const rootProps = {
        onBlur
      };
      return _extends({}, rootProps, resolveComponentProps(pickerSlotProps == null ? void 0 : pickerSlotProps.fieldRoot, ownerState));
    },
    separator: pickerSlotProps == null ? void 0 : pickerSlotProps.fieldSeparator
  });
  const restFieldProps = _objectWithoutPropertiesLoose(fieldProps, _excluded6);
  const enrichedFieldProps = _extends({}, restFieldProps, {
    slots,
    slotProps
  });
  return enrichedFieldProps;
};
var useSingleInputFieldSlotProps = ({
  wrapperVariant,
  open,
  actions,
  readOnly,
  inputRef: inInputRef,
  labelId,
  disableOpenPicker,
  label,
  onBlur,
  rangePosition,
  onRangePositionChange,
  singleInputFieldRef,
  pickerSlots,
  pickerSlotProps,
  fieldProps,
  anchorRef
}) => {
  const inputRef = React13.useRef(null);
  const handleInputRef = useForkRef(inInputRef, inputRef);
  const handleFieldRef = useForkRef(fieldProps.unstableFieldRef, singleInputFieldRef);
  React13.useEffect(() => {
    var _inputRef$current;
    if (!open) {
      return;
    }
    (_inputRef$current = inputRef.current) == null || _inputRef$current.focus();
  }, [rangePosition, open]);
  const updateRangePosition = () => {
    var _singleInputFieldRef$;
    if (!singleInputFieldRef.current || inputRef.current !== getActiveElement(document)) {
      return;
    }
    const sections = singleInputFieldRef.current.getSections();
    const activeSectionIndex = (_singleInputFieldRef$ = singleInputFieldRef.current) == null ? void 0 : _singleInputFieldRef$.getActiveSectionIndex();
    const domRangePosition = activeSectionIndex == null || activeSectionIndex < sections.length / 2 ? "start" : "end";
    if (domRangePosition != null && domRangePosition !== rangePosition) {
      onRangePositionChange(domRangePosition);
    }
  };
  const handleSelectedSectionsChange = useEventCallback_default((selectedSections) => {
    var _fieldProps$onSelecte;
    setTimeout(updateRangePosition);
    (_fieldProps$onSelecte = fieldProps.onSelectedSectionsChange) == null || _fieldProps$onSelecte.call(fieldProps, selectedSections);
  });
  const openPicker = (event) => {
    event.stopPropagation();
    if (!readOnly && !disableOpenPicker) {
      actions.onOpen();
    }
  };
  const slots = _extends({}, fieldProps.slots, {
    textField: pickerSlots == null ? void 0 : pickerSlots.textField,
    clearButton: pickerSlots == null ? void 0 : pickerSlots.clearButton,
    clearIcon: pickerSlots == null ? void 0 : pickerSlots.clearIcon
  });
  const slotProps = _extends({}, fieldProps.slotProps, {
    textField: pickerSlotProps == null ? void 0 : pickerSlotProps.textField,
    clearButton: pickerSlots == null ? void 0 : pickerSlots.clearButton,
    clearIcon: pickerSlots == null ? void 0 : pickerSlots.clearIcon
  });
  const enrichedFieldProps = _extends({}, fieldProps, {
    slots,
    slotProps,
    label,
    unstableFieldRef: handleFieldRef,
    inputRef: handleInputRef,
    onKeyDown: onSpaceOrEnter(openPicker, fieldProps.onKeyDown),
    onSelectedSectionsChange: handleSelectedSectionsChange,
    onBlur,
    InputProps: _extends({
      ref: anchorRef
    }, fieldProps == null ? void 0 : fieldProps.InputProps),
    focused: open
  }, labelId != null && {
    id: labelId
  }, wrapperVariant === "mobile" && {
    readOnly: true
  }, !readOnly && !fieldProps.disabled && {
    onClick: openPicker
  });
  return enrichedFieldProps;
};
var useEnrichedRangePickerFieldProps = (params) => {
  if (true) {
    const fieldTypeRef = React13.useRef(params.fieldType);
    if (params.fieldType !== fieldTypeRef.current) {
      console.error("Should not switch between a multi input field and a single input field on a range picker.");
    }
  }
  if (params.fieldType === "multi-input") {
    return useMultiInputFieldSlotProps(params);
  }
  return useSingleInputFieldSlotProps(params);
};

// node_modules/@mui/x-date-pickers-pro/internals/hooks/useDesktopRangePicker/useDesktopRangePicker.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime());
var import_jsx_runtime12 = __toESM(require_jsx_runtime());
var _excluded7 = ["props"];
var releaseInfo3 = getReleaseInfo();
var useDesktopRangePicker = (_ref) => {
  var _fieldType, _slots$layout;
  let {
    props
  } = _ref, pickerParams = _objectWithoutPropertiesLoose(_ref, _excluded7);
  useLicenseVerifier("x-date-pickers-pro", releaseInfo3);
  const {
    slots,
    slotProps,
    className,
    sx,
    format,
    formatDensity,
    timezone,
    label,
    inputRef,
    name,
    readOnly,
    disabled,
    autoFocus,
    disableOpenPicker,
    localeText,
    reduceAnimations
  } = props;
  const fieldContainerRef = React14.useRef(null);
  const anchorRef = React14.useRef(null);
  const popperRef = React14.useRef(null);
  const {
    rangePosition,
    onRangePositionChange,
    singleInputFieldRef
  } = useRangePosition(props);
  const {
    open,
    actions,
    layoutProps,
    renderCurrentView,
    shouldRestoreFocus,
    fieldProps: pickerFieldProps
  } = usePicker(_extends({}, pickerParams, {
    props,
    wrapperVariant: "desktop",
    autoFocusView: true,
    additionalViewProps: {
      rangePosition,
      onRangePositionChange
    }
  }));
  const handleBlur = () => {
    executeInTheNextEventLoopTick(() => {
      var _fieldContainerRef$cu, _popperRef$current;
      if ((_fieldContainerRef$cu = fieldContainerRef.current) != null && _fieldContainerRef$cu.contains(getActiveElement(document)) || (_popperRef$current = popperRef.current) != null && _popperRef$current.contains(getActiveElement(document))) {
        return;
      }
      actions.onDismiss();
    });
  };
  const Field = slots.field;
  const fieldType = (_fieldType = Field.fieldType) != null ? _fieldType : "multi-input";
  const fieldProps = useSlotProps({
    elementType: Field,
    externalSlotProps: slotProps == null ? void 0 : slotProps.field,
    additionalProps: _extends({}, pickerFieldProps, {
      readOnly,
      disabled,
      className,
      sx,
      format,
      formatDensity,
      timezone,
      autoFocus: autoFocus && !props.open,
      ref: fieldContainerRef
    }, fieldType === "single-input" && {
      inputRef,
      name
    }),
    ownerState: props
  });
  const enrichedFieldProps = useEnrichedRangePickerFieldProps({
    wrapperVariant: "desktop",
    fieldType,
    open,
    actions,
    readOnly,
    disableOpenPicker,
    label,
    localeText,
    onBlur: handleBlur,
    rangePosition,
    onRangePositionChange,
    singleInputFieldRef,
    pickerSlotProps: slotProps,
    pickerSlots: slots,
    fieldProps,
    anchorRef
  });
  const slotPropsForLayout = _extends({}, slotProps, {
    toolbar: _extends({}, slotProps == null ? void 0 : slotProps.toolbar, {
      rangePosition,
      onRangePositionChange
    })
  });
  const Layout = (_slots$layout = slots == null ? void 0 : slots.layout) != null ? _slots$layout : PickersLayout;
  const renderPicker = () => (0, import_jsx_runtime12.jsxs)(LocalizationProvider, {
    localeText,
    children: [(0, import_jsx_runtime11.jsx)(Field, _extends({}, enrichedFieldProps)), (0, import_jsx_runtime11.jsx)(PickersPopper, _extends({
      role: "tooltip",
      placement: "bottom-start",
      containerRef: popperRef,
      anchorEl: anchorRef.current,
      onBlur: handleBlur
    }, actions, {
      open,
      slots,
      slotProps,
      shouldRestoreFocus,
      reduceAnimations,
      children: (0, import_jsx_runtime11.jsx)(Layout, _extends({}, layoutProps, slotProps == null ? void 0 : slotProps.layout, {
        slots,
        slotProps: slotPropsForLayout,
        children: renderCurrentView()
      }))
    }))]
  });
  return {
    renderPicker
  };
};

// node_modules/@mui/x-date-pickers-pro/DesktopDateRangePicker/DesktopDateRangePicker.js
var DesktopDateRangePicker = React15.forwardRef(function DesktopDateRangePicker2(inProps, ref) {
  var _defaultizedProps$cal, _defaultizedProps$slo2;
  const defaultizedProps = useDateRangePickerDefaultizedProps(inProps, "MuiDesktopDateRangePicker");
  const viewRenderers = _extends({
    day: renderDateRangeViewCalendar
  }, defaultizedProps.viewRenderers);
  const props = _extends({}, defaultizedProps, {
    viewRenderers,
    calendars: (_defaultizedProps$cal = defaultizedProps.calendars) != null ? _defaultizedProps$cal : 2,
    views: ["day"],
    openTo: "day",
    slots: _extends({
      field: MultiInputDateRangeField
    }, defaultizedProps.slots),
    slotProps: _extends({}, defaultizedProps.slotProps, {
      field: (ownerState) => {
        var _defaultizedProps$slo;
        return _extends({}, resolveComponentProps((_defaultizedProps$slo = defaultizedProps.slotProps) == null ? void 0 : _defaultizedProps$slo.field, ownerState), extractValidationProps(defaultizedProps), {
          ref
        });
      },
      toolbar: _extends({
        hidden: true
      }, (_defaultizedProps$slo2 = defaultizedProps.slotProps) == null ? void 0 : _defaultizedProps$slo2.toolbar)
    })
  });
  const {
    renderPicker
  } = useDesktopRangePicker({
    props,
    valueManager: rangeValueManager,
    valueType: "date",
    validator: validateDateRange
  });
  return renderPicker();
});
DesktopDateRangePicker.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: import_prop_types5.default.bool,
  /**
   * The number of calendars to render on **desktop**.
   * @default 2
   */
  calendars: import_prop_types5.default.oneOf([1, 2, 3]),
  /**
   * Class name applied to the root element.
   */
  className: import_prop_types5.default.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: import_prop_types5.default.bool,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: import_prop_types5.default.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: import_prop_types5.default.object,
  /**
   * Position the current month is rendered in.
   * @default 1
   */
  currentMonthCalendarPosition: import_prop_types5.default.oneOf([1, 2, 3]),
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {string} day The day of week provided by the adapter.  Deprecated, will be removed in v7: Use `date` instead.
   * @param {TDate} date The date of the day of week provided by the adapter.
   * @returns {string} The name to display.
   * @default (_day: string, date: TDate) => adapter.format(date, 'weekdayShort').charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: import_prop_types5.default.func,
  /**
   * Default calendar month displayed when `value={[null, null]}`.
   * @deprecated Consider using `referenceDate` instead.
   */
  defaultCalendarMonth: import_prop_types5.default.any,
  /**
   * The initial position in the edited date range.
   * Used when the component is not controlled.
   * @default 'start'
   */
  defaultRangePosition: import_prop_types5.default.oneOf(["end", "start"]),
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: import_prop_types5.default.arrayOf(import_prop_types5.default.any),
  /**
   * If `true`, after selecting `start` date calendar will not automatically switch to the month of `end` date.
   * @default false
   */
  disableAutoMonthSwitching: import_prop_types5.default.bool,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: import_prop_types5.default.bool,
  /**
   * If `true`, editing dates by dragging is disabled.
   * @default false
   */
  disableDragEditing: import_prop_types5.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types5.default.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: import_prop_types5.default.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: import_prop_types5.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types5.default.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: import_prop_types5.default.bool,
  /**
   * Calendar will show more weeks in order to match this value.
   * Put it to 6 for having fix number of week in Gregorian calendars
   * @default undefined
   */
  fixedWeekNumber: import_prop_types5.default.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: import_prop_types5.default.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: import_prop_types5.default.oneOf(["dense", "spacious"]),
  /**
   * Pass a ref to the `input` element.
   * Ignored if the field has several inputs.
   */
  inputRef: refType_default,
  /**
   * The label content.
   * Ignored if the field has several inputs.
   */
  label: import_prop_types5.default.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: import_prop_types5.default.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: import_prop_types5.default.object,
  /**
   * Maximal selectable date.
   */
  maxDate: import_prop_types5.default.any,
  /**
   * Minimal selectable date.
   */
  minDate: import_prop_types5.default.any,
  /**
   * Name attribute used by the `input` element in the Field.
   * Ignored if the field has several inputs.
   */
  name: import_prop_types5.default.string,
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   */
  onAccept: import_prop_types5.default.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: import_prop_types5.default.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: import_prop_types5.default.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
   *
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error describing why the current value is not valid.
   * @param {TValue} value The value associated to the error.
   */
  onError: import_prop_types5.default.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: import_prop_types5.default.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: import_prop_types5.default.func,
  /**
   * Callback fired when the range position changes.
   * @param {RangePosition} rangePosition The new range position.
   */
  onRangePositionChange: import_prop_types5.default.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: import_prop_types5.default.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: import_prop_types5.default.bool,
  /**
   * The position in the currently edited date range.
   * Used when the component position is controlled.
   */
  rangePosition: import_prop_types5.default.oneOf(["end", "start"]),
  readOnly: import_prop_types5.default.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: import_prop_types5.default.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
   */
  referenceDate: import_prop_types5.default.any,
  /**
   * Component displaying when passed `loading` true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => "..."
   */
  renderLoading: import_prop_types5.default.func,
  /**
   * The currently selected sections.
   * This prop accept four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
   * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 4. If `null` is provided, no section will be selected
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: import_prop_types5.default.oneOfType([import_prop_types5.default.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), import_prop_types5.default.number, import_prop_types5.default.shape({
    endIndex: import_prop_types5.default.number.isRequired,
    startIndex: import_prop_types5.default.number.isRequired
  })]),
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (e.g. when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @param {string} position The date to test, 'start' or 'end'.
   * @returns {boolean} Returns `true` if the date should be disabled.
   */
  shouldDisableDate: import_prop_types5.default.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: import_prop_types5.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types5.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types5.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types5.default.oneOfType([import_prop_types5.default.arrayOf(import_prop_types5.default.oneOfType([import_prop_types5.default.func, import_prop_types5.default.object, import_prop_types5.default.bool])), import_prop_types5.default.func, import_prop_types5.default.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documention} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types5.default.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types5.default.arrayOf(import_prop_types5.default.any),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be the used.
   */
  viewRenderers: import_prop_types5.default.shape({
    day: import_prop_types5.default.func
  })
};

// node_modules/@mui/x-date-pickers-pro/MobileDateRangePicker/MobileDateRangePicker.js
init_extends();
var React17 = __toESM(require_react());
var import_prop_types6 = __toESM(require_prop_types());
init_esm();

// node_modules/@mui/x-date-pickers-pro/internals/hooks/useMobileRangePicker/useMobileRangePicker.js
init_extends();
init_objectWithoutPropertiesLoose();
var React16 = __toESM(require_react());
init_useId();
var import_jsx_runtime13 = __toESM(require_jsx_runtime());
var import_jsx_runtime14 = __toESM(require_jsx_runtime());
var _excluded8 = ["props"];
var releaseInfo4 = getReleaseInfo();
var useMobileRangePicker = (_ref) => {
  var _fieldType, _innerSlotProps$toolb, _innerSlotProps$toolb2, _slots$layout;
  let {
    props
  } = _ref, pickerParams = _objectWithoutPropertiesLoose(_ref, _excluded8);
  useLicenseVerifier("x-date-pickers-pro", releaseInfo4);
  const {
    slots,
    slotProps: innerSlotProps,
    className,
    sx,
    format,
    formatDensity,
    timezone,
    label,
    inputRef,
    name,
    readOnly,
    disabled,
    disableOpenPicker,
    localeText
  } = props;
  const {
    rangePosition,
    onRangePositionChange,
    singleInputFieldRef
  } = useRangePosition(props);
  const labelId = useId();
  const contextLocaleText = useLocaleText();
  const {
    open,
    actions,
    layoutProps,
    renderCurrentView,
    fieldProps: pickerFieldProps
  } = usePicker(_extends({}, pickerParams, {
    props,
    wrapperVariant: "mobile",
    autoFocusView: true,
    additionalViewProps: {
      rangePosition,
      onRangePositionChange
    }
  }));
  const Field = slots.field;
  const fieldType = (_fieldType = Field.fieldType) != null ? _fieldType : "multi-input";
  const fieldProps = useSlotProps({
    elementType: Field,
    externalSlotProps: innerSlotProps == null ? void 0 : innerSlotProps.field,
    additionalProps: _extends({}, pickerFieldProps, {
      readOnly: readOnly != null ? readOnly : true,
      disabled,
      className,
      sx,
      format,
      formatDensity,
      timezone
    }, fieldType === "single-input" && {
      inputRef,
      name
    }),
    ownerState: props
  });
  const isToolbarHidden = (_innerSlotProps$toolb = innerSlotProps == null || (_innerSlotProps$toolb2 = innerSlotProps.toolbar) == null ? void 0 : _innerSlotProps$toolb2.hidden) != null ? _innerSlotProps$toolb : false;
  const enrichedFieldProps = useEnrichedRangePickerFieldProps({
    wrapperVariant: "mobile",
    fieldType,
    open,
    actions,
    readOnly,
    labelId,
    disableOpenPicker,
    label,
    localeText,
    rangePosition,
    onRangePositionChange,
    singleInputFieldRef,
    pickerSlots: slots,
    pickerSlotProps: innerSlotProps,
    fieldProps
  });
  const slotPropsForLayout = _extends({}, innerSlotProps, {
    toolbar: _extends({}, innerSlotProps == null ? void 0 : innerSlotProps.toolbar, {
      titleId: labelId,
      rangePosition,
      onRangePositionChange
    })
  });
  const Layout = (_slots$layout = slots == null ? void 0 : slots.layout) != null ? _slots$layout : PickersLayout;
  const finalLocaleText = _extends({}, contextLocaleText, localeText);
  let labelledById = labelId;
  if (isToolbarHidden) {
    const labels = [];
    if (fieldType === "multi-input") {
      if (finalLocaleText.start) {
        labels.push(`${labelId}-start-label`);
      }
      if (finalLocaleText.end) {
        labels.push(`${labelId}-end-label`);
      }
    } else if (label != null) {
      labels.push(`${labelId}-label`);
    }
    labelledById = labels.length > 0 ? labels.join(" ") : void 0;
  }
  const slotProps = _extends({}, innerSlotProps, {
    mobilePaper: _extends({
      "aria-labelledby": labelledById
    }, innerSlotProps == null ? void 0 : innerSlotProps.mobilePaper)
  });
  const renderPicker = () => (0, import_jsx_runtime14.jsxs)(LocalizationProvider, {
    localeText,
    children: [(0, import_jsx_runtime13.jsx)(Field, _extends({}, enrichedFieldProps)), (0, import_jsx_runtime13.jsx)(PickersModalDialog, _extends({}, actions, {
      open,
      slots,
      slotProps,
      children: (0, import_jsx_runtime13.jsx)(Layout, _extends({}, layoutProps, slotProps == null ? void 0 : slotProps.layout, {
        slots,
        slotProps: slotPropsForLayout,
        children: renderCurrentView()
      }))
    }))]
  });
  return {
    renderPicker
  };
};

// node_modules/@mui/x-date-pickers-pro/MobileDateRangePicker/MobileDateRangePicker.js
var MobileDateRangePicker = React17.forwardRef(function MobileDateRangePicker2(inProps, ref) {
  var _defaultizedProps$slo2;
  const defaultizedProps = useDateRangePickerDefaultizedProps(inProps, "MuiMobileDateRangePicker");
  const viewRenderers = _extends({
    day: renderDateRangeViewCalendar
  }, defaultizedProps.viewRenderers);
  const props = _extends({}, defaultizedProps, {
    viewRenderers,
    calendars: 1,
    views: ["day"],
    openTo: "day",
    slots: _extends({
      field: MultiInputDateRangeField
    }, defaultizedProps.slots),
    slotProps: _extends({}, defaultizedProps.slotProps, {
      field: (ownerState) => {
        var _defaultizedProps$slo;
        return _extends({}, resolveComponentProps((_defaultizedProps$slo = defaultizedProps.slotProps) == null ? void 0 : _defaultizedProps$slo.field, ownerState), extractValidationProps(defaultizedProps), {
          ref
        });
      },
      toolbar: _extends({
        hidden: false
      }, (_defaultizedProps$slo2 = defaultizedProps.slotProps) == null ? void 0 : _defaultizedProps$slo2.toolbar)
    })
  });
  const {
    renderPicker
  } = useMobileRangePicker({
    props,
    valueManager: rangeValueManager,
    valueType: "date",
    validator: validateDateRange
  });
  return renderPicker();
});
MobileDateRangePicker.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: import_prop_types6.default.bool,
  /**
   * The number of calendars to render on **desktop**.
   * @default 2
   */
  calendars: import_prop_types6.default.oneOf([1, 2, 3]),
  /**
   * Class name applied to the root element.
   */
  className: import_prop_types6.default.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: import_prop_types6.default.bool,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: import_prop_types6.default.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: import_prop_types6.default.object,
  /**
   * Position the current month is rendered in.
   * @default 1
   */
  currentMonthCalendarPosition: import_prop_types6.default.oneOf([1, 2, 3]),
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {string} day The day of week provided by the adapter.  Deprecated, will be removed in v7: Use `date` instead.
   * @param {TDate} date The date of the day of week provided by the adapter.
   * @returns {string} The name to display.
   * @default (_day: string, date: TDate) => adapter.format(date, 'weekdayShort').charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: import_prop_types6.default.func,
  /**
   * Default calendar month displayed when `value={[null, null]}`.
   * @deprecated Consider using `referenceDate` instead.
   */
  defaultCalendarMonth: import_prop_types6.default.any,
  /**
   * The initial position in the edited date range.
   * Used when the component is not controlled.
   * @default 'start'
   */
  defaultRangePosition: import_prop_types6.default.oneOf(["end", "start"]),
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: import_prop_types6.default.arrayOf(import_prop_types6.default.any),
  /**
   * If `true`, after selecting `start` date calendar will not automatically switch to the month of `end` date.
   * @default false
   */
  disableAutoMonthSwitching: import_prop_types6.default.bool,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: import_prop_types6.default.bool,
  /**
   * If `true`, editing dates by dragging is disabled.
   * @default false
   */
  disableDragEditing: import_prop_types6.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types6.default.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: import_prop_types6.default.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: import_prop_types6.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types6.default.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: import_prop_types6.default.bool,
  /**
   * Calendar will show more weeks in order to match this value.
   * Put it to 6 for having fix number of week in Gregorian calendars
   * @default undefined
   */
  fixedWeekNumber: import_prop_types6.default.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: import_prop_types6.default.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: import_prop_types6.default.oneOf(["dense", "spacious"]),
  /**
   * Pass a ref to the `input` element.
   * Ignored if the field has several inputs.
   */
  inputRef: refType_default,
  /**
   * The label content.
   * Ignored if the field has several inputs.
   */
  label: import_prop_types6.default.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: import_prop_types6.default.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: import_prop_types6.default.object,
  /**
   * Maximal selectable date.
   */
  maxDate: import_prop_types6.default.any,
  /**
   * Minimal selectable date.
   */
  minDate: import_prop_types6.default.any,
  /**
   * Name attribute used by the `input` element in the Field.
   * Ignored if the field has several inputs.
   */
  name: import_prop_types6.default.string,
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   */
  onAccept: import_prop_types6.default.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: import_prop_types6.default.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: import_prop_types6.default.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
   *
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error describing why the current value is not valid.
   * @param {TValue} value The value associated to the error.
   */
  onError: import_prop_types6.default.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: import_prop_types6.default.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: import_prop_types6.default.func,
  /**
   * Callback fired when the range position changes.
   * @param {RangePosition} rangePosition The new range position.
   */
  onRangePositionChange: import_prop_types6.default.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: import_prop_types6.default.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: import_prop_types6.default.bool,
  /**
   * The position in the currently edited date range.
   * Used when the component position is controlled.
   */
  rangePosition: import_prop_types6.default.oneOf(["end", "start"]),
  readOnly: import_prop_types6.default.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: import_prop_types6.default.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
   */
  referenceDate: import_prop_types6.default.any,
  /**
   * Component displaying when passed `loading` true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => "..."
   */
  renderLoading: import_prop_types6.default.func,
  /**
   * The currently selected sections.
   * This prop accept four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
   * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 4. If `null` is provided, no section will be selected
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: import_prop_types6.default.oneOfType([import_prop_types6.default.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), import_prop_types6.default.number, import_prop_types6.default.shape({
    endIndex: import_prop_types6.default.number.isRequired,
    startIndex: import_prop_types6.default.number.isRequired
  })]),
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (e.g. when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @param {string} position The date to test, 'start' or 'end'.
   * @returns {boolean} Returns `true` if the date should be disabled.
   */
  shouldDisableDate: import_prop_types6.default.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: import_prop_types6.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types6.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types6.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types6.default.oneOfType([import_prop_types6.default.arrayOf(import_prop_types6.default.oneOfType([import_prop_types6.default.func, import_prop_types6.default.object, import_prop_types6.default.bool])), import_prop_types6.default.func, import_prop_types6.default.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documention} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types6.default.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types6.default.arrayOf(import_prop_types6.default.any),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be the used.
   */
  viewRenderers: import_prop_types6.default.shape({
    day: import_prop_types6.default.func
  })
};

// node_modules/@mui/x-date-pickers-pro/DateRangePicker/DateRangePicker.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime());
var _excluded9 = ["desktopModeMediaQuery"];
var DateRangePicker = React18.forwardRef(function DateRangePicker2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDateRangePicker"
  });
  const {
    desktopModeMediaQuery = "@media (pointer: fine)"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded9);
  const isDesktop = useMediaQuery(desktopModeMediaQuery, {
    defaultMatches: true
  });
  if (isDesktop) {
    return (0, import_jsx_runtime15.jsx)(DesktopDateRangePicker, _extends({
      ref
    }, other));
  }
  return (0, import_jsx_runtime15.jsx)(MobileDateRangePicker, _extends({
    ref
  }, other));
});
true ? DateRangePicker.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: import_prop_types7.default.bool,
  /**
   * The number of calendars to render on **desktop**.
   * @default 2
   */
  calendars: import_prop_types7.default.oneOf([1, 2, 3]),
  /**
   * Class name applied to the root element.
   */
  className: import_prop_types7.default.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: import_prop_types7.default.bool,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: import_prop_types7.default.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: import_prop_types7.default.object,
  /**
   * Position the current month is rendered in.
   * @default 1
   */
  currentMonthCalendarPosition: import_prop_types7.default.oneOf([1, 2, 3]),
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {string} day The day of week provided by the adapter.  Deprecated, will be removed in v7: Use `date` instead.
   * @param {TDate} date The date of the day of week provided by the adapter.
   * @returns {string} The name to display.
   * @default (_day: string, date: TDate) => adapter.format(date, 'weekdayShort').charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: import_prop_types7.default.func,
  /**
   * Default calendar month displayed when `value={[null, null]}`.
   * @deprecated Consider using `referenceDate` instead.
   */
  defaultCalendarMonth: import_prop_types7.default.any,
  /**
   * The initial position in the edited date range.
   * Used when the component is not controlled.
   * @default 'start'
   */
  defaultRangePosition: import_prop_types7.default.oneOf(["end", "start"]),
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: import_prop_types7.default.arrayOf(import_prop_types7.default.any),
  /**
   * CSS media query when `Mobile` mode will be changed to `Desktop`.
   * @default '@media (pointer: fine)'
   * @example '@media (min-width: 720px)' or theme.breakpoints.up("sm")
   */
  desktopModeMediaQuery: import_prop_types7.default.string,
  /**
   * If `true`, after selecting `start` date calendar will not automatically switch to the month of `end` date.
   * @default false
   */
  disableAutoMonthSwitching: import_prop_types7.default.bool,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: import_prop_types7.default.bool,
  /**
   * If `true`, editing dates by dragging is disabled.
   * @default false
   */
  disableDragEditing: import_prop_types7.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types7.default.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: import_prop_types7.default.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: import_prop_types7.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types7.default.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: import_prop_types7.default.bool,
  /**
   * Calendar will show more weeks in order to match this value.
   * Put it to 6 for having fix number of week in Gregorian calendars
   * @default undefined
   */
  fixedWeekNumber: import_prop_types7.default.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: import_prop_types7.default.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: import_prop_types7.default.oneOf(["dense", "spacious"]),
  /**
   * Pass a ref to the `input` element.
   * Ignored if the field has several inputs.
   */
  inputRef: refType_default,
  /**
   * The label content.
   * Ignored if the field has several inputs.
   */
  label: import_prop_types7.default.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: import_prop_types7.default.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: import_prop_types7.default.object,
  /**
   * Maximal selectable date.
   */
  maxDate: import_prop_types7.default.any,
  /**
   * Minimal selectable date.
   */
  minDate: import_prop_types7.default.any,
  /**
   * Name attribute used by the `input` element in the Field.
   * Ignored if the field has several inputs.
   */
  name: import_prop_types7.default.string,
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   */
  onAccept: import_prop_types7.default.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: import_prop_types7.default.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: import_prop_types7.default.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
   *
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error describing why the current value is not valid.
   * @param {TValue} value The value associated to the error.
   */
  onError: import_prop_types7.default.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: import_prop_types7.default.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: import_prop_types7.default.func,
  /**
   * Callback fired when the range position changes.
   * @param {RangePosition} rangePosition The new range position.
   */
  onRangePositionChange: import_prop_types7.default.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: import_prop_types7.default.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: import_prop_types7.default.bool,
  /**
   * The position in the currently edited date range.
   * Used when the component position is controlled.
   */
  rangePosition: import_prop_types7.default.oneOf(["end", "start"]),
  readOnly: import_prop_types7.default.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: import_prop_types7.default.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
   */
  referenceDate: import_prop_types7.default.any,
  /**
   * Component displaying when passed `loading` true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => "..."
   */
  renderLoading: import_prop_types7.default.func,
  /**
   * The currently selected sections.
   * This prop accept four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
   * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 4. If `null` is provided, no section will be selected
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: import_prop_types7.default.oneOfType([import_prop_types7.default.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), import_prop_types7.default.number, import_prop_types7.default.shape({
    endIndex: import_prop_types7.default.number.isRequired,
    startIndex: import_prop_types7.default.number.isRequired
  })]),
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (e.g. when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @param {string} position The date to test, 'start' or 'end'.
   * @returns {boolean} Returns `true` if the date should be disabled.
   */
  shouldDisableDate: import_prop_types7.default.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: import_prop_types7.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types7.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types7.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types7.default.oneOfType([import_prop_types7.default.arrayOf(import_prop_types7.default.oneOfType([import_prop_types7.default.func, import_prop_types7.default.object, import_prop_types7.default.bool])), import_prop_types7.default.func, import_prop_types7.default.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documention} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types7.default.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types7.default.arrayOf(import_prop_types7.default.any),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be the used.
   */
  viewRenderers: import_prop_types7.default.shape({
    day: import_prop_types7.default.func
  })
} : void 0;
export {
  DateRangePicker,
  DateRangePickerToolbar,
  dateRangePickerToolbarClasses,
  getDateRangePickerToolbarUtilityClass
};
/*! Bundled license information:

@mui/x-license-pro/index.js:
  (**
   * @mui/x-license-pro v6.10.2
   *
   * @license MUI X Commercial
   * This source code is licensed under the commercial license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@mui_x-date-pickers-pro_DateRangePicker.js.map
